#!/usr/bin/env bash

# Qataki is free and unencumbered public domain software. For more
# information see http://unlicense.org/ or the accompanying UNLICENSE file.

# The OAuth bits in this script (TO_* functions) and company from
# qataki.utils file) are copyright (c) 2010 by Yu-Jie Lin:
# http://blog.yjl.im/2010/05/bash-oauth.html

# OAuth_PE in qataki.utils file was replaced with some awk magic
# by Heiner Steven's urlencode script:
# http://www.shelldorado.com/scripts/cmds/urlencode

# You can modify default options in $conf_file ($HOME/.qataki/qataki.conf)

usage() {
case $1 in
	file_miss)
		echo 'File is either non-existent or its size is 0.'
		exit 1 ;;
	empty)
		echo 'Forgot an option?'
		exit 1 ;;
	no_alias)
		echo "Alias is not configured in $conf_file"
		exit 1 ;;
	no_both)
		echo "Can't have both"
		exit 1 ;;
	no_auth)
		echo "Have you set up $conf_file correctly? Try \"$(basename $0) k\""
		exit 1 ;;
	no_impl)
		echo "Not implemented"
		exit 1 ;;
	number)
		echo "That option needs a number <= $opt_max_stats"
		exit 1 ;;
	invalid_paste)
	cat <<EOB
		Invalid paste string or an invalid file.
		Valid string examples: %%syntax:file or %%file
		If "file" is an image, it should have jpg, png or gif extension.
		"syntax" is optional: if present it's the language of "file" and
		can be one of those listed here: http://pastebin.com/api.php.
		If paste string is OK, then there is something wrong with "file".
EOB
		exit 1 ;;
	*)
		# It used to be cleaner, but configurable keys were added...
		# At least it shows OK on console.
		cat <<EOH

$(basename $0) [i|t|s:<SITE>] [n:<NICK>] [<OPTION> [<ARGUMENT>]]

The first (optional) flag can be: i (identi.ca) OR t (twitter)OR
s:<SITE> (see below). If none of these three flags are given,
then Identi.ca will be used. It is possible to use only 1 OPTION
and, eventually, its ARGUMENT. If no option is passed, messages
from people you follow will be retrieved by default.
Options have a default value, but it is possible to modify defaults
by adding/changing key_*=VALUE in $conf_file (defaults after RESULT).

OPTION    ARGUMENT           RESULT

          [+|$key_number]              Retrieve messages from people you follow.
                             If you use the optional "+" argument, all statuses
                             will be displayed. Otherwise only new statuses.
                             If you use $key_number (default: key_number=e) then enumerate
                             new statuses to read.
$key_public                            Retrieve messages from public timeline.
                             Default: key_public=p
$key_group         <GROUP>            Retrieve messages from <GROUP timeline.
                             Default: key_group=g
$key_update         "message"          Update your status with a "message".
                             Default: key_update=u
$key_update_w                            Type an update message in your \$EDITOR.
                             Default: key_update_w=U
$key_mentions         [+]                Show notices where you are mentioned (@you).
                             If you use the optional "+" argument, all statuses
                             will be displayed. Otherwise only new statuses.
                             Default: key_mentions=m
$key_reply         <NUMBER> "message" Reply to message number <NUMBER> with "message".
                             Default: key_reply=r
$key_reply_w         <NUMBER>           Reply to message number <NUMBER> by using \$EDITOR.
                             Default: key_reply_w=Y
$key_context         <NUMBER>           Show conversation relative to notice <NUMBER>.
                             Default: key_context=c
$key_alt_nick:<NICK>  <OPTION>           Use an alternate nick. This option can be
                             preceded by [i|t|s:<SITE>] (i by default).
                             Default: key_alt_nick=n
$key_user         <USER>             Show <USER>'s timeline (last statuses).
                             Default: key_user=N
$key_prev                            Show previous (last) messages.
                             Default: key_prev=P
$key_info_msg         <NUMBER>           Show details about notice <NUMBER> (note that
                             short links will be replaced by real links).
                             Default: key_info_msg=d
$key_sn:<SITE>  <OPTION>           Use <OPTION> (exept s itself) on <SITE>.
                             Default: key_sn=s
$key_configure                            Configure an account.
                             Default: key_configure=k
$key_search         "string"           Search messages with "string".
                             Default: key_search=S
$key_resend         <NUMBER>           Retweet/redent message number <NUMBER>.
                             Default: key_resend=R
$key_comment         <NUMBER> [message] Retweet/redent message number <NUMBER>. The option
                             differs from the previous because you can:
                             1) Optionally add a message before resent message;
                             2) Transforms groups tags in hashtags (available
                                only for Identi.ca/StatusNet sites).
                             Technically, this option generates a reply.
                             Default: key_comment=C
$key_comment_w         <NUMBER>          As above, but use \$EDITOR to compose a comment.
                              Default: key_comment_w=Q
$key_dir_msg_send         <USER> "message"   Send a direct msg (with text "message") to <USER>.
                             Default: key_dir_msg_send=M
$key_follow         <USER>|<NUMBER>    Follow someone (AKA subscribe).
                             Default: key_follow=f
$key_unfollow         <USER>|<NUMBER>    Unfollow someone (AKA unsubscribe).
                             Default: key_follow=F
$key_join         <GROUP>            Join <GROUP>.
                             Default: key_join=j
$key_unjoin         <GROUP>            Unjoin <GROUP>.
                             Default: key_unjoin=J
$key_like         <NUMBER>           Add notice <NUMBER> to favorites list.
                             Default: key_like=a
$key_open         <NUMBER>           Open a link present in notice <NUMBER> in your
                             \$BROWSER. If more than 1 link is present, a menu
                             to choose from will be displayed.
                             Default: key_open=o

NOTES:

"message" is the message/status you want to send. Enclose it in single or
          double quotes. (Remember to escape them if you use them in your
          message: "It's \\"my message\\"" or 'It\\'s "my message"'.
          It's possible to include a pastebin link or a link with a thumbnail
          of an image in your message. If you want to upload, for instance, a
          shell file and inlude its link in the message include it like:
          "A shell script: %%bash:file.sh".
          It will be replaced by "A shell script: http://pastebin.com/example".
          If "file" is an image (jpg, png or gif), it will be uploaded to
          omploader.org and a link for the image will appear in the message:
          "A photo: %%file.png".
          It will be replaced by "A photo: http://omploader.org/example".
          The general "paste string" is %%syntax:file or %%file. In the former
          case the paste will be highlighted according to syntax. Available
          syntaxes are shown here: http://pastebin.com/api.php
<NUMBER>  is the tweet/dent number displayed on the left when you run
          "$(basename $0) [i|t|s<SITE>] [n:<NICK>] [N <USER>]".
<GROUP>   is the name of an Identi.ca/StatusNet group.
<NICK>    is an alternate nickname. You have to pass *alternate* nicknames
          on the command line as n:<NICK>. On the contrary, you don't have
          to specify your *default* nickname. For this, your default nick
          has to be placed in $conf_file. This is done by default when
          you use the "k" option. Anyway, the syntax for default nicks is:

          default_user_SERVICE=YOUR_DEFAULT_NICK

          where "SERVICE" can be identica, twitter or <SITE> (see below)
          and YOUR_DEFAULT_NICK is... your default nickname on SERVICE.
<USER>    is a user's nickname (AKA screen_name; no spaces).
<SITE>    is an alias for a StatusNet compatible site. This alias is
          the second field of a line on $conf_file structured like:

          site ALIAS http://micro.example.com

          You'll be able to use ALIAS as argument for "s" option, like:

          "$(basename $0) s:ALIAS [n:<NICK>]".

          (with the latter example you'll see notices from people you
          follow on http://micro.example.com). For convevience, try to keep
          ALIAS short.

Authorisation is handled by curl with its "-n" option. This means that a
.netrc file (located in $conf_dir) is used. Qataki generates .netrc dinamically
when it's run (a 0077 umask is used). When it exits .netrc is restored.
(Note that your \$HOME/.netrc won't be touched.)

When you run qataki with the "k" option, you can add your username and password
to $conf_file. If you ever need to do it by hand, its syntax is:

machine SERVICE login YOU password PASS

where SERVICE can be identi.ca OR twitter.com (and api.twitter.com) OR
a StatusNet compatible microblogging site (without "http://").

EOH
	exit 1 ;;
esac
}

# You will notice that curl is called as /usr/bin/env HOME=$conf_dir curl ...
# This is a security feature (thanks to Svend at Super Dimension Fortress).
# This way it's possible to create .netrc in $conf_dir ($HOME/.qataki/.netrc)
# so that we don't mess up the real .netrc (in $HOME/.netrc).

conf_dir=$HOME/.qataki
conf_file=$conf_dir/qataki.conf
cache_dir=$conf_dir/cache
tmp_file=$cache_dir/tmp
kill_file=$conf_dir/killfile
twitter=http://api.twitter.com/1
identica=http://identi.ca/api

umask 0077

fn_configuration() {
	echo "Create/modify account? [Y/n]"
	read -n 1 ans && echo
	[[ $ans = [nN]* ]] && echo 'Nothing done!' && exit 1

	echo >> $conf_file

	select i in Identi.ca Twitter StatusNet ; do
		[[ $REPLY != [123] ]] && continue
		case $REPLY in
			1|2) if [[ $REPLY -eq 1 ]] ; then
				v_site=identi.ca v_site_name=identica
				else
					v_site=twitter.com v_site_name=twitter
				fi ;;
			3)	while [[ -z $v_site ]] ; do
					echo "StatusNet site (e.g., http://micro.example.com):"
					read v_site
				done
				while [[ -z $v_site_name ]] ; do
					echo "Choose an alias for $v_site (a short alphanum word)"
					read v_site_name
					if [[ $v_site_name = *[!a-zA-Z0-9]* ]] ; then
						echo "Alphanumeric! Try again." && exit 1
					fi
				done

				v_site_full=$v_site
				v_site=${v_site/http:\/\/} ; v_site=${v_site%/}
		esac

		[[ $REPLY -le 3 ]] && break
	done

	echo "Configuring $i"

	while [[ -z $v_nick ]] ; do
		echo "Nickname:"
		read v_nick
	done

	while [[ -z $v_pass ]] ; do
		echo "Password:"
		read -r v_pass
	done

	echo "Is $v_nick your default $v_site account? [Y/n]"
	read -n 1 ans && echo
	if [[ $ans != [nN] ]] ; then
		if grep default_user_$v_site_name 1>/dev/null $conf_file ; then
			echo "You already had a default $v_site account."
		else
			echo "default_user_$v_site_name=$v_nick" >> $conf_file
		fi
	else
		if ! grep default_user_$v_site_name 1>/dev/null $conf_file ; then
			echo "You don't have a default $v_site account."
			echo "Run this configuration again with your default account first."
			exit 1
		fi
	fi

	if grep "machine $v_site login $v_nick" 1>/dev/null $conf_file ; then
		echo 'That account was already present. Nothing changed.'
	else
		echo "machine $v_site login $v_nick password $v_pass" >> $conf_file
		if [[ $v_site = 'twitter.com' ]] ; then # api.twitter.com *also* needed
			echo "machine api.$v_site login $v_nick password $v_pass" >> $conf_file
		fi

	fi

	[[ $REPLY -eq 3 ]] && echo "site $v_site_name $v_site_full" >> $conf_file

	echo "Done!"
	exit 0
}

[[ ! -d $cache_dir ]] && mkdir -p $cache_dir # Also $conf_dir
[[ ! -f $tmp_file ]] && > $tmp_file
if [[ ! -f $conf_file ]] ; then
	cat <<-EOC > $conf_file
		# These are options you can modify:
		opt_pager_opts='-REX' # Options for pager (less)
		opt_max_chars=140     # Max characters on update messages
		opt_max_stats=30      # Max number of statuses to display
		opt_editor=           # Options for your $EDITOR
		opt_order=default     # 'default' -> as website; 'date' -> chronological
		opt_show_date=0       # If = 1 dates will be displayed with statuses
		opt_kill=0            # If = 1 notices that contain strings from
		                      #        $kill_file will be grepped out
		opt_from=Qataki       # Change for whatever you like.
EOC
	fn_configuration
fi


# Default options. Can be changed in $conf_file
key_public=p key_update=u key_update_w=U key_mentions=m key_reply=r
key_user=N key_search=S key_context=c key_group=g key_resend=R key_info_msg=d
key_dir_msg_send=M key_configure=k key_help=h key_Help=H key_prev=P
key_alt_nick=n key_sn=s key_follow=f key_unfollow=F key_join=j key_unjoin=J
key_delete=D key_like=a key_open=o key_comment=C key_block=b key_unblock=B
key_number=e key_comment_w=Q key_reply_w=Y key_info_user=z

for i in $(grep -o "^\(key\|opt\)_[^ 	]*" $conf_file) ; do
	eval $i
done

opt_pager_opts=${opt_pager_opts:-'-REX'} opt_max_chars=${opt_max_chars:-140}
opt_max_stats=${opt_max_stats:-30} opt_order=${opt_order:-default}
opt_from=${opt_from:-Qataki} opt_show_date=${opt_show_date:-0}
opt_kill=${opt_kill:-0}

site=$identica api=statuses last_file=$cache_dir/last.dent
[[ $1 = i ]] && shift

if [[ $1 = $key_alt_nick:* ]] ; then
	my_nick=$1 my_nick=${my_nick/n:}
	last_file=$last_file.$my_nick
	shift
else
	my_nick=$(sed -n "s/^default_user_identica=//p" $conf_file)
fi

if [[ $1 = t ]] ; then
	site=$twitter last_file=$cache_dir/last.tweet
	if [[ $2 = $key_alt_nick:* ]] ; then
		my_nick=$2 my_nick=${my_nick/n:}
		last_file=$last_file.$my_nick
		shift
	else
		my_nick=$(sed -n "s/^default_user_twitter=//p" $conf_file)
	fi
	shift
fi


if [[ $1 = $key_sn:* ]] ; then
	# Identi.ca is not present inside [[ ]] as it's the default value
	# and will be overwritten anyway if "s:..." is specified
	[[ $site = *twitter* ]] && usage no_both
	site_alias=$1 site_alias=${site_alias/s:}
	if [[ -z $2 ]] ; then
		usage empty
	else
		[[ ! $(grep "site $site_alias " $conf_file) ]] && usage no_alias
		if [[ $2 = $key_alt_nick:* ]] ; then
			my_nick=$2 my_nick=${my_nick/n:}
			last_file=$last_file.$my_nick
			shift
		else
			my_nick=$(sed -n "s/^default_user_$site_alias=//p" $conf_file)
		fi
	fi
	site=$(awk '/^site(\t| )+'$site_alias'/ {print $3}' $conf_file)
	site=${site%/}/api
	last_file=$cache_dir/last.$site_alias
	shift
fi

# $last_file is 3 lines, where last statuses ids will be placed
[[ ! -f $last_file ]] && printf "\n\n\n" > $last_file

site=${site%/} # Be sure to leave out trailing slash
cols=$(( $(tput cols) - 2 ))
[[ $cols -le 10 ]] && cols=78 # If 'tput cols' fails
if which par 1>/dev/null 2>&1 ; then
	par_exe=1
	b_cols=300 # Columns for $BROWSER. Note that it's not $cols
else
	b_cols=$cols
fi

sort=sort # If gsort is present, we are on BSD and need gsort:
if which gsort 1>/dev/null 2>&1 ; then
	sort=gsort
fi

if which elinks 1>/dev/null 2>&1 ; then
	browser=${BROWSER:-elinks}
	render="elinks -dump -dump-width \$b_cols -no-numbering -force-html \
	  -eval 'set document.browse.margin_width = 1' -no-references"
else
	browser=${BROWSER:-lynx}
	# There's a -nomargins option, but it's less readable
	render="lynx -assume_charset=utf-8 -dump -width \$b_cols -force_html -stdin \
	   -nonumbers -hiddenlinks=ignore -nolist"
fi

# Valid characters for for #hashes, @users, !groups
chars='a-zA-Z0-9_-'

# Embed colour sequences
if [[ -f $conf_dir/${opt_theme#opt_theme=} ]] ; then
	source $conf_dir/${opt_theme#opt_theme=}
else
	col_normal='[0m'
	col_nick='[1;33;40m'
	col_follow='[0;30;43m'
	col_reply='[1;35;40m'
	col_link='[1;36;40m'
	col_hash='[1;32;40m'
	col_group='[1;31;40m'
fi

curl="eval /usr/bin/env HOME=$conf_dir curl"

# When local function's $1=search, more passages are needed
fn_download() {
	curl_opts="-f -s -n $curl_extra_opts"
	api_url=$2
	api_params=$(IFS='' ; for (( i=3; i<=${#@}; i++ )) ; do
				eval printf "%s" "--data-urlencode\ \$$i\ "
			done)
	{
	case $1 in
		no_file)
			$curl $curl_opts $api_url $api_params >/dev/null ;;
		file)
			$curl $curl_opts $api_url $api_params > $tmp_file ;;
		search)
			$curl $curl_opts $api_url $api_params | \
			  sed '1,/<status>/ { /Search/d ; };
			  s@<\(/*\)title>@<\1text>@g;s@<\(/*\)entry>@<\1status>@g;
			  s@<name>\([^< ][^< ]*\).*</name>@<screen_name>\1</screen_name>@'\
			    > $tmp_file ;;
	esac
	} || exit 1

	# A file <= 3 lines (always sufficient?) is a file with an error
	[[ $(wc -l < $tmp_file) -gt 3 ]] && return || exit 2
}

# First, remove tags with sed and put contents on a line. Then, search
# for tags of interest with awk, put them in a variable, and show them
# in specific order when a defined tag is reached. I know the awk stuff
# is a bit ugly ;) I'll change it, some day...
fn_extract() {
sed '/<retweeted_status>/,/<\/retweeted_status>/ !{
s@\(>*\)\([^<>]*\)\(<*\)@\1\
\2\
\3@g
}' $tmp_file | sed '/^$/d;/[<>]/d' | \
awk -v show_date=$opt_show_date -v curr_date=$(date +%s)  \
  ' /^(screen_name)|(text)|(in_reply_to_screen_name)|(following)|(created_at)$/,/^(\/screen_name)|(\/text)|(\/in_reply_to_screen_name)|(\/following)|(\/created_at)$/ {
if ( $1 ~ /^screen_name$/ ) { sn=1 ; next }
if ( $1 ~ /^following$/ ) { foll=1 ;  next }
if ( $1 ~ /^text$/ ) { txt=1 ; next }
if ( $1 ~ /^in_reply_to_screen_name$/ ) { rep=1 ; next }
if ( $1 ~ /^created_at$/ ) {
	if (status_date == "") { date=1 ; next } else { next } }
if ( $1 ~ /^\/screen_name$/ ) { sn=0 ; next }
if ( $1 ~ /^\/text$/ ) { txt=0 ;  next }
if ( $1 ~ /^\/in_reply_to_screen_name$/ ) { rep=0; next }
if ( $1 ~ /^\/following$/ ) { foll=0 ; next }
if ( $1 ~ /^\/created_at$/ ) { date=0 ;  next }
if ( sn == 1 ) { sn_content=sn_content $0 }
if ( txt == 1 ) { txt_content=txt_content $0 }
if ( rep == 1 ) { rep_content=rep_content $0 }
if ( foll == 1 ) { foll_mark=$0 }
if ( ( show_date == 1 ) && ( date == 1 ) ) {
	orig_date=$0
	"date -d \""orig_date"\" +%s" | getline status_date_sec
	close("date -d \""orig_date"\" +%s")
	past_seconds=curr_date-status_date_sec
	minutes=int(past_seconds/60)
	hours=int(minutes/60)
	days=int(hours/24)
	if ( minutes <= 1 ) { status_date="Less than a minute ago" }
	else if ( ( minutes >= 1 ) && ( minutes < 60 ) ) { status_date=minutes " minutes ago" }
	else if ( hours < 24 ) { { if ( hours > 1 ) { s_h="s" } }
		minutes=int(minutes - hours * 60) ; status_date=hours " hour" s_h " " minutes " minutes ago" }
	else if ( days < 30 ) { hours=int( hours - days * 24 ) ; status_date=days " days ago" }
	else { status_date="More than 1 month ago" }
	status_date="[" status_date "]"
	}
}
/^\/status$/ {
txt_content=txt_content " " status_date
if (rep_content) { txt_content=txt_content " {context}" }
if (foll_mark=="true") { foll_mark="###" } else { foll_mark="" }
print "*" foll_mark sn_content "*: " txt_content
txt_content=""; sn_content=""; rep_content=""; status_date=""
}'
}

# An attempt to support conversations. Should be rewritten when API
# has method for conversations. Basically, the page with the main
# notice is downloaded (passed with $1) and formatted.
# XXX There's already a conversation API. SHould keep this for
# compatibility reasosn for sn < version 1.0 ??
#fn_conversation() {
#	curl -s "$1" | \
#	  sed -n '/<div id="content">/,/<div id="aside_primary"/ p' | \
#	  sed '/<img src=/d;s/<p class=/<span class=/;s@</p>@</span>@;
#	    s@\(<span class="nickname fn">\)\(.*\)\(</span>\)@\1*\2*: \3@'
#}

# Return an ordered list for notices: # <ol><li>Notice 1<li>Notice 2..</ol>
fn_ol_list() {
	if [[ $par_exe -ne 1 ]] ; then
		awk 'BEGIN { print "<ol>" } { print "<li>" $0 } END { print "</ol>" } '
	else
		if [[ $opt_order = date ]] ; then
			awk '{ print NR ".", $0 "<br>" }' | $sort -nr
		else
			awk '{ print NR ".", $0 "<br>" }'
		fi
	fi | \
	if [[ $opt_kill = 1 && -s $kill_file ]] ; then
		grep -v -i -f $HOME/.qataki/killfile
	else
		cat - # UUOC ?!?!?
	fi
	#awk 'BEGIN { print "<ol>" } { print "<li>" $0 } END { print "</ol>" } '
}


# Links are searched in a way that http, ftp and gopher are valid links.
fn_format() {
	# If called with a parameter 'par' won't be used (see e.g., "conversation")
	# B+_x5D_x7D means "add ']' and '}' as body characters".
	if [[ -z $1 && $par_exe -eq 1 ]] ; then
		eval $render | par B+_x5D_x7D ${cols}p5dh
	else
		eval $render
	fi | \
	sed "s/^\([^1-9]*[1-9][0-9]*\.[^\*]*\)\*###\([^ ][^ ]*\)\*:/\1$col_follow\2$col_normal:/;\
	  s/^\([^1-9]*[1-9][0-9]*\.[^\*]*\)\*\([^ ][^ ]*\)\*:/\1$col_nick\2$col_normal:/;\
	  s@\([fgh][a-zA-Z]*://[^ ][^ ]*[a-zA-Z0-9/]\)@$col_link\1$col_normal@g;\
	  s/\(@[$chars][$chars]*\)/$col_reply\1$col_normal/g;\
	  s/\(#[$chars][$chars]*\)/$col_hash\1$col_normal/g;\
	  s/\(![$chars][$chars]*\)/$col_group\1$col_normal/g;\
	  s/\({context}\)$/[1m\1[0m/"
}

fn_info_user() {
answ=$1 # user nick

date=$(sed -n '/<\/user>/q;
  /<user>/,/<\/user>/ s@[[:space:]]*<created_at>\([^<]*\)</created_at>@\1@p' $tmp_file)
notices=$(sed -n '/<\/user>/q;
  /<user>/,/<\/user>/ s@[[:space:]]*<statuses_count>\([^<]*\)</statuses_count>@\1@p' $tmp_file)
if [[ -n $date ]] ; then
	date1=$(date -d "$date" +%s)
	date2=$(date +%s)
	# XXX In a sane shell (ksh93), we could do...
	#average=$(( notices/86400 ))
	# ... but bash guys want we to use bc (XXX: Check that bc is installed?)
	average=$(echo "scale=2; $notices*86400/($date2-$date1)" | bc)
fi

sed '/<\/user>/q; s/&lt;/</g;s/&gt;/>/g;s/&quot;/"/g' $tmp_file | \
awk -F'[<>]' -v avg=$average -v stat=$notices -v date="$date" '
/<name>/ { name=$3 }
/<location>/ { loc=$3 }
/<description>/ { desc=$3 }
/<followers_count>/ { foll=$3 }
/<friends_count>/ { frie=$3 }
END {
print "<li>Name: " name
print "<li>Since: " date
if (loc!="") { print "<li>Location: " loc }
if (desc!="") { print "<li>Description: " desc }
print "<li>Followers: " foll
print "<li>Following: " frie
print "<li>Notices: " stat
print "<li>Average: " avg
print "<li>Last update:"
}' | fn_format
#sed -n "/<user>/,/<\/user>/ {
#s@<name>\([^<]*\)</name>@<li>Name: \1 (created: $date)@p
#s@<location>\([^<]*\)</location>@<li>Location: \1@p
#s@<description>\([^<]*\)</description>@<li>Description: \1@p
#s@<followers_count>\([^<]*\)</followers_count>@<li>Followers: \1@p
#s@<friends_count>\([^<]*\)</friends_count>@<li>Following: \1@p
#s@<statuses_count>\([^<]*\)</statuses_count>@<li>Notices: \1@p
#}" | fn_format
}

fn_info_msg() {
answ=$1 # This variable is always the notice number.

status_start=$(sed -n '/<status>/=' $tmp_file | sed -n ${answ}p)
status_end=$(sed -n '/<\/status>/=' $tmp_file | sed -n ${answ}p)

# Sometimes a status can have a new line: s@^[[:space:]]...
sed 's/&lt;/</g;s/&gt;/>/g;s/&quot;/"/g' $tmp_file | \
sed -n "$status_start,$status_end {
s@<text>\([^<]*\)<*.*@<li>Status: \1@p
s@^[[:space:]][[:space:]]*[^<[:space:]]\([^<][^<]*\)<*/.*@\1@p
s@<screen_name>\(.*\)</screen_name>@<li>Nick: \1@p
s@<name>\(.*\)</name>@<li>Name: \1@p
s@<location>\(.*\)</location>@<li>Location: \1@p
s@<url>\(.*\)</url>@<li>URL: \1@p
/<status>/,/<user>/ {
s@<created_at>\(.*\)</created_at>@<li>Date: \1@p
s@<source>\(.*\)</source>@<li>From: \1@p
}
}" | fn_real_urls | fn_format

}

# Search for the first <id> and assign its value to $last. (Even if
# both <status> and <user> have an <id>, <status> always comes first.)
# Then, update $last file with this new value.
# The argument passed to this function is the kind of <id> on which we
# are interested on: 1 => home_timeline; 2 => mentions; 3 => public timeline
fn_last_status() {
last=$(sed -n '/<id>/p' $tmp_file | \
  sed -n '1s@[[:space:]]*<id>\([^<]*\)</id>@\1@p')
sed "$1 c\\
$last
" $last_file > $last_file.tmp
mv $last_file.tmp $last_file
}

# Prints URLs. XXX: gopher? ftp?
#If shorten=1 will print the entire message with shortened URLS
fn_url() {
	awk -v how=$1 ' BEGIN {
	curl_call_start="curl -s -G --data-urlencode url=\""
	curl_call_end="\" -d key=d8a413748aa7b34a191fc96d6c98dd1a -d appid=Qataki http://cli.gs/api/v1/cligs/create"
	if (how == "short" ) { ORS=" " } }
	{
	url_re = "https?://"
	for (i=1; i<=NF; i++) {
			if (match($i, url_re)) {
				real_url=$i
				if ( how == "short" ) {
					curl_call_start real_url curl_call_end | getline url
					close(curl_call_start real_url curl_call_end) }
				else { url=real_url }
				print url
			} else { if ( how == "short" ) { print $i } }
	}}'
}

# Extract title from URL ($1).
# Original idea by @ksaver http://identi.ca/ksaver
fn_url_title() {
	curl -ks "$1" | awk 'BEGIN { ORS=" " }
	  /<[Tt][Ii][Tt][Ll][Ee]>/,/<\/[Tt][Ii][Tt][Ll][Ee]>/ { print $0 }' | \
	sed 's@.*<[Tt][Ii][Tt][Ll][Ee]>\(.*\)</[Tt][Ii][Tt][Ll][Ee]>.*$@\1@'
}

# This will output HTTP header field "Location".
# So, give this function a short URL, and will output real URL.
# XXX: close() awk???
fn_real_urls() {
	awk ' BEGIN { ORS=" " }
	/Status:/ {
	url_re = "http://[^ ]+"
	for (i=1; i<=NF; i++) {
		if (i==NF) { ORS="\n" }
		x=$i
		if (match($i, url_re)) {
			"curl -s -I \""$i"\" | sed -n \"s@Location: \\(.*\\)@\\1@p\"" | \
			  getline x
			print x
		} else { print x }
	} }
	!/Status:/ { print }
	'
}

fn_editor_update() {
	editor=${EDITOR:-vi}
	tmp_status=${TMP:-/tmp}/qataki_$(id -u).$$
	echo "$1" > $tmp_status
	eval $editor $opt_editor $tmp_status
	msg=$(tr '\n' ' ' < $tmp_status)
	rm $tmp_status
}

fn_prepare_auth() {
	site_name=${site/*:\/\/} ; site_name=${site_name%/*}

	# \(api.\)\?... shuld match api.twitter.com, so \(api.\)*...
	grep "machine \(api.\)*$site_name login $my_nick" $conf_file \
	  > $conf_dir/.netrc

	# Check that site (without http[s]://) is in .netrc
	[[ -z $(grep $site_name $conf_dir/.netrc 2>/dev/null) ]] && usage no_auth
}

fn_status_info() {
	delim_1="$1" delim_2="$2" tag_o="$3" tag_c="</${tag_o#<}"
	sed -n "/<retweeted_status>/,/<\/retweeted_status>/ !{
	$delim_1,$delim_2 {
	  /$tag_o/ p
	}
	}" $tmp_file | sed -n "$status_num s@.*$tag_o\($tag_cont_re*\)$tag_c@\1@p"
}

fn_paste() {
	paste_string=$(echo "$msg" | sed 's/[^%]*%%\([^ ]*\).*/\1/')
	# $syntax shouldn't be done with ${paste_string%:*}
	syntax=$(echo $paste_string | sed -n 's/\([^:][^:]\):.*/\1/p')
	file=${paste_string#*:}
	file_ext=$(echo ${file#*.} | tr '[A-Z]' '[a-z]')
	[[ ! -s $file ]] && usage file_miss
	[[ -n $syntax ]] && extra_paste="-d paste_format=$syntax"

	case $file_ext in
		jp*g|png|gif) # Upload file to omploader.org and return URL
			paste=$(curl -s -F "file1=@$file" http://omploader.org/upload | \
			  sed -n '/ file:/ s/.*\(http[^<]*\).*/\1/p') ;;
		*) # Otherwise use pastebin.com
			paste=$(curl -s $extra_paste --data-urlencode "paste_code@$file" \
			  http://pastebin.com/api_public.php) ;;
	esac

	if echo "$paste" | grep ' ' 1>/dev/null 2>&1 ; then
		usage invalid_paste
	else
		msg=$(echo "$msg" | sed "s@\([^%]*\)%%[^ ]*\(.*\)@\1${paste}\2@")
	fi
}

# Choose if $1 is we will use screen_name or id to refer to user ($1)
fn_name_id() {
	if [[ $1 != *[a-zA-Z]* && $1 -le $opt_max_stats ]] ; then
		# It's a number and probably not a username
		status_num=$1 tag_cont_re='.'
		user=$(fn_status_info '/<user>/' '/<\/user>/' '<id>')
		user_ident=user_id
	else
		user=$1
		user_ident=screen_name
	fi
}

# For auth we will generate a new .netrc site, after moving the old one.
# When the scripts exits, restore .netrc (a sane umask was already set):
trap "rm -f $conf_dir/.netrc" EXIT

read parameters_line <<< $(echo " $@") # XXX portability :(
while read -t 1 line ; do # XXX again :((
	parameters_pipe="$parameters_pipe $line"
done

parameters="$parameters_line $parameters_pipe"

# XXX: This shouldn't work in ksh93
for i in $parameters ; do
	param[${#param[@]}]=$i
done

# This is for pipes
fn_parameters() {
	for (( i=$1 ; i<$2 ; i++ )) ; do
		last_param="$last_param ${param[$i]}"
	done
	echo ${last_param# }
}

# Options that need authentication
[[ ${param[0]} = *[$key_update$key_update_w$key_reply$key_mentions$key_sn\
$key_resend$key_dir_msg_send$key_delete$key_follow$key_unfollow$key_join\
$key_unjoin$key_like$key_comment$key_block$key_unblock$key_comment_w\
$key_reply_w] ]] && fn_prepare_auth

fn_auth_header() {
	auth_header=$(OAuth_authorization_header 'Authorization' \
	  'http://api.twitter.com' '' '' "$1" "$2"  ${oauth_params[@]})
}

fn_oauth_params() {
	oauth_params=( )
	for (( i=2; i<=${#@} ; i=i+2 )) ; do
		eval param_name=\$$(( i-1 )) param_val=\$$i
		oauth_params[${#oauth_params[@]}]=$(OAuth_param "$param_name" "$param_val")
	done
}

TO_extract_value() {
	# $1 key name
	# $2 string to find
	egrep -o "$1=[a-zA-Z0-9-]*" <<< "$2" | cut -d\= -f 2
}

TO_access_token_helper() {
	# Help guide user to get access token
	local resp PIN
	# Request Token
	local auth_header="$(_OAuth_authorization_header 'Authorization' 'http://api.twitter.com/' "$oauth_consumer_key" "$oauth_consumer_secret" '' '' "$oauth_signature_method" "$oauth_version" "$(OAuth_nonce)" "$(OAuth_timestamp)" 'POST' "$T_REQUEST_TOKEN" "$(OAuth_param 'oauth_callback' 'oob')"), $(OAuth_param_quote 'oauth_callback' 'oob')"
	resp=$(curl -k -s -d '' -H "$auth_header" "$T_REQUEST_TOKEN")
	TO_rval=$?
	[[ $? != 0 ]] && return $TO_rval
	local _oauth_token=$(TO_extract_value 'oauth_token' "$resp")
	local _oauth_token_secret=$(TO_extract_value 'oauth_token_secret' "$resp")

	echo "Please go to the following link to get the PIN :"
	echo "  ${T_AUTHORIZE_TOKEN}?$_oauth_token"

	read -p 'PIN: ' PIN

	# Access Token
	local auth_header="$(_OAuth_authorization_header 'Authorization' 'http://api.twitter.com/' "$oauth_consumer_key" "$oauth_consumer_secret" "$_oauth_token" "$_oauth_token_secret" "$oauth_signature_method" "$oauth_version" "$(OAuth_nonce)" "$(OAuth_timestamp)" 'POST' "$T_ACCESS_TOKEN" "$(OAuth_param 'oauth_verifier' "$PIN")"), $(OAuth_param_quote 'oauth_verifier' "$PIN")"

	resp=$(curl -k -s -d "" -H "$auth_header" "$T_ACCESS_TOKEN")
	TO_rval=$?
	[[ $? != 0 ]] && return $TO_rval

	TO_ret=(
		$(TO_extract_value 'oauth_token' "$resp")
		$(TO_extract_value 'oauth_token_secret' "$resp")
		$(TO_extract_value 'user_id' "$resp")
		$(TO_extract_value 'screen_name' "$resp")
		)
}

if [[ $site = *twitter* ]] ; then
	auth=oauth ; oauth_version='1.0'
	oauth_ck=TZwBrnCnAQn ; oauth_cs=BovVTVLz8bi0HGTVLl2s3b3
	oauth_signature_method='HMAC-SHA1'
	oauth_consumer_key=${oauth_ck}X6OjYuqiaIw
	oauth_consumer_secret=${oauth_cs}J4U3khDoUqQPkjQ5u9mI
	if [[ -f $conf_dir/qataki.utils ]] ; then
		source $conf_dir/qataki.utils
	elif [[ -f qataki.utils ]] ; then
		source qataki.utils
	else
		cat <<-EOB
		Please copy the 'qataki.utils' file in $conf_dir/qataki.utils
		You can find a copy of it at http://github.com/chr/qataki/
EOB
		exit 10
	fi
	oauth_token=$(grep ^oauth_token_twitter $conf_file)
	oauth_token_secret=$(grep ^oauth_token_secret_twitter $conf_file)
	eval oauth_token=${oauth_token#*=}
	eval oauth_token_secret=${oauth_token_secret#*=}
	if [[ -z $oauth_token || -z $oauth_token_secret ]] ; then
		T_REQUEST_TOKEN='https://api.twitter.com/oauth/request_token'
		T_AUTHORIZE_TOKEN='http://chr.tx0.org/qataki/oauth'
		T_ACCESS_TOKEN='https://api.twitter.com/oauth/access_token'
		TO_access_token_helper
		if (( $? == 0 )); then
			oauth_token=${TO_ret[0]}
			oauth_token_secret=${TO_ret[1]}
			echo "oauth_token_twitter='${TO_ret[0]}'" >> $conf_file
			echo "oauth_token_secret_twitter='${TO_ret[1]}'" >> $conf_file
		else
			echo 'Unable to get access token'
			exit 1
		fi
	fi

	oauth_basic_params=$(fn_oauth_params 'oauth_consumer_key' "$oauth_consumer_key" \
	  'oauth_signature_method' '$oauth_signature_method' 'oauth_version' '$oauth_version')

fi

# XXX: Rewrite options parsing.
case ${param[0]} in
	*$key_public)
		last_stat=$(sed -n "3p" $last_file 2>/dev/null)
		[[ ${param[1]} = '+' || ! -n $last_stat ]] && last_stat=1

		data="$site/$api/public_timeline.xml?count=$opt_max_stats"
		fn_download file $site/$api/public_timeline.xml && fn_last_status 3 ;;
	*[$key_update$key_update_w])
		if [[ ${param[0]} = $key_update ]] ; then
			msg=$(fn_parameters 1 ${#param[@]})
		else
			msg= ; fn_editor_update
		fi

		if echo "$msg" | grep '%%' 1>/dev/null 2>&1 ; then
			fn_paste
		elif echo "$msg" | grep '^http[^ ]*' 1>/dev/null 2>&1 ; then
			link_title=$(fn_url_title $msg)
			msg="$link_title $msg"
		fi

		# XXX: True only for Identi.ca and Twitter
		[[ ${#msg} -gt $opt_max_chars ]] && msg=$(echo "$msg" | fn_url short)
		[[ ${#msg} -gt $opt_max_chars ]] && echo "Message too long." && exit 1

		if [[ $auth = oauth ]] ; then
			# XXX: This kind of array assign works only in bash...
			fn_oauth_params 'status' "$msg" 'source' "$opt_from"
			fn_auth_header POST $site/$api/update.xml
			curl_extra_opts="-H \"$auth_header\""
		fi

		fn_download no_file $site/$api/update.xml \
		  "source=$opt_from" "status=\"$msg\""
		exit 0 ;;
	*$key_mentions)
		last_stat=$(sed -n "2p" $last_file 2>/dev/null)
		[[ ${param[1]} = '+' || ! -n $last_stat ]] && last_stat=1

		if [[ $auth = oauth ]] ; then
			fn_oauth_params 'since_id' "$last_stat" 'count' "$opt_max_stats"
			fn_auth_header POST $site/$api/mentions.xml
			curl_extra_opts="-H \"$auth_header\""
		fi

		fn_download file $site/$api/mentions.xml \
		  "since_id=$last_stat" "count=$opt_max_stats" && fn_last_status 2 ;;
	*[$key_reply$key_reply_w$key_comment$key_comment_w])
		msg=$(fn_parameters 2 ${#param[@]})

		if [[ -z ${param[1]} || ${param[1]} = *[!0-9]* ]] ; then
			echo 'Select a number' && exit 1
		fi

		status_num=${param[1]} tag_cont_re='.'
		reply_to=$(fn_status_info '/<status>/' '/<user>/' '<id>')
		user_name=$(fn_status_info '/<user>/' '/<status>/' '<screen_name>')

		if [[ ${param[0]} = [$key_comment$key_comment_w] ]] ; then
			comment=$(fn_status_info '/<status>/' '/<user>/' '<text>' | \
			  sed 's/!\([^[:space:]][^[:space:]]*\)/#\1/g')
			[[ $site = *twitter* ]] && resend=RT || resend=RD
			if [[ ${param[0]} = $key_comment_w ]] ; then
				msg= ; fn_editor_update "$resend @$user_name $comment"
				reply_status=$msg
			else
				reply_status="$msg $resend @$user_name $comment"
			fi
		elif [[ ${param[0]} = $key_reply_w ]] ; then
			fn_editor_update "@$user_name"
			reply_status="$msg"
		else
			[[ -z $msg ]] && echo "Message?" && exit 1
			reply_status="@$user_name $msg"
		fi

		if [[ $auth = oauth ]] ; then
			fn_oauth_params 'status' "${reply_status# }" 'source' "$opt_from" \
			  'in_reply_to_status_id' "$reply_to"
			fn_auth_header POST $site/$api/update.xml
			curl_extra_opts="-H \"$auth_header\""
		fi

		# XXX: @file is recognised by curl. Problems?
		fn_download no_file $site/$api/update.xml "source=$opt_from" \
		  "status=\"${reply_status# }\"" "in_reply_to_status_id=$reply_to"
		exit 0 ;;
	*[$key_user$key_info_user])
		user=${param[1]}
		curl_extra_opts='-G'

		fn_name_id ${param[1]}

		[[ ${param[0]} = $key_info_user ]] && opt_max_stats=1

		if [[ $auth = oauth ]] ; then
			fn_oauth_params "$user_ident" "$user" 'count' "$opt_max_stats"
			#oauth_params=( $(OAuth_param 'screen_name' "$user") )
			#oauth_params[${#oauth_params[@]}]=$(OAuth_param 'count' "$opt_max_stats")
			fn_auth_header GET $site/$api/user_timeline.xml
			curl_extra_opts="-G -H \"$auth_header\""
		fi

		fn_download file $site/$api/user_timeline.xml \
		  "$user_ident=$user" "count=$opt_max_stats"

		[[ ${param[0]} = $key_info_user ]] && fn_info_user ;;
	*$key_search)
		if [[ "$site" == *twitter* ]] ; then
			site=http://search.twitter.com
		fi

		string=$(fn_parameters 1 ${#param[@]})

		if [[ $auth = oauth ]] ; then
			fn_oauth_params 'rpp' "$opt_max_stats" 'q' "$string"
			fn_auth_header GET $site/search.atom
			curl_extra_opts="-H \"$auth_header\""
		fi

		fn_download search $site/search.atom \
		  "rpp=$opt_max_stats" "q=$string" ;;
	*$key_context)
		[[ "$site" == *twitter* ]] && usage no_impl

		# Retrive conversation URL from status id
		#b_cols=$cols
		status_num=${param[1]} tag_cont_re='.'
		#context_id=$(fn_status_info '/<status>/' '/<user>/' '<id>')
		#conversation_url=$(curl -L -s "${site%/api}/notice/$context_id" | \
		#  sed -n "/>in context</ { s/[^\"]*\"\([^#]*\).*/\1/ p
		#    }")
		# Format conversation
		#fn_conversation "$conversation_url" | fn_format conversation | \
		#  sed "/^$/d;s/ \{10\}/        $col_nick|$col_normal/g" | \
		#  sed "s/ \{5\}/  $col_hash|$col_normal/g" | \
		#  less $opt_pager_opts
		#  exit 0 ;;


		# NEW
		context_id=$(fn_status_info '/<status>/' '/<\/status>/' '<statusnet:conversation_id>')
		api=statusnet/conversation
		fn_download file $site/$api/$context_id.xml ;;
		# /NEW

	*[$key_group$key_join$key_unjoin])
		[[ "$site" == *twitter* ]] && usage no_impl
		group=${param[1]}
		api=statusnet
		if [[ ${param[0]} = *$key_group ]] ; then
			fn_download file $site/$api/groups/timeline.xml \
			  "id=$group" "count=$opt_max_stats"
		else
			[[ ${param[0]} = *$key_join ]] && kind=join || kind=leave
			curl_extra_opts="$opt_curl_extra_post_head -X POST"
			fn_download no_file $site/$api/groups/$kind/$group.xml && exit 0
		fi ;;
	*[$key_resend$key_delete$key_like])
		if grep '<feed ' $tmp_file 1>/dev/null ; then
		re1='$' re2=':' # This case is when file returned is Atom
		else
			re1='/<user>/' re2='<id>' # This is normal case (e.g., API)
		fi

		status_num=${param[1]} tag_cont_re='.'
		notice_id=$(fn_status_info '/<status>/' "$re1" "$re2")

		#if [[ "$site" == *twitter* ]] ; then
		#	site=http://api.twitter.com/1
		#fi

		if [[ ${param[0]} = *$key_like ]] ; then
			api=favorites
			#[[ "$site" == *twitter* ]] && api=favorites || api=api/favorites
			kind=create
		else
			[[ ${param[0]} = *$key_resend ]] && kind=retweet || kind=destroy
		fi

		curl_extra_opts="$opt_curl_extra_post_head -X POST"

		if [[ $auth = oauth ]] ; then
			fn_oauth_params 'source' "$opt_from"
			fn_auth_header POST $site/$api/$kind/$notice_id.xml
			curl_extra_opts="-H \"$auth_header\""
		fi

		fn_download no_file $site/$api/$kind/$notice_id.xml "source=$opt_from"
		exit 0 ;;
	*$key_dir_msg_send)
		to_user=${param[1]} # XXX: FIX URL
		[[ $to_user = *[!a-zA-Z0-9]* ]] && { echo 'username is alphanum' ; exit 1 ; }
		[[ -n ${param[2]} ]] && dir_msg=$(fn_parameters 2 ${#param[@]}) || { echo 'Enter a message' ; exit 1 ; }
		#[[ "$site" == *twitter* ]] && unset api
		curl_extra_opts="$opt_curl_extra_post_head -X POST"

		if [[ $auth = oauth ]] ; then
			fn_oauth_params 'source' "$opt_from" 'user' "$to_user" 'text' "$dir_msg"
			fn_auth_header POST $site/direct_messages/new.xml
			curl_extra_opts="-H \"$auth_header\""
		fi

		fn_download no_file $site/direct_messages/new.xml \
		  "source=$opt_from" "user=$to_user" "text=$dir_msg"
		exit 0 ;;
	*$key_info_msg)
		# XXX: What was next line for???
		#grep '<verified>' $tmp_file 1>/dev/null || site=$identica # verif -> tw
		fn_info_msg ${param[1]} && exit 0 ;;
	*$key_configure)
		fn_configuration ;;
	*[$key_help$key_Help])
		usage ;;
	*$key_prev) : ;; # Do nothing: Messages are already in $tmp_file
	*[$key_follow$key_unfollow$key_block$key_unblock])
		# XXX: block API issues.
		[[ ${param[0]} = [$key_follow$key_unfollow] ]] && api=friendships || api=blocks

		[[ ${param[0]} = *[$key_follow$key_block] ]] && kind=create || kind=destroy

		fn_name_id ${param[1]}

		curl_extra_opts="$opt_curl_extra_post_head -X POST"

		if [[ $auth = oauth ]] ; then
			fn_oauth_params "$user_ident" "$user"
			fn_auth_header POST $site/$api/$kind.xml
			curl_extra_opts="-H \"$auth_header\""
		fi

		fn_download no_file $site/$api/$kind.xml "$user_ident=$user"
		exit 0 ;;
	*$key_open)
		if [[ ${param[1]} != *[a-zA-Z]* && ${param[1]} -le $opt_max_stats ]] ; then
			status_num=${param[1]} tag_cont_re='.'
			# If there's a NL it won't take all the text.
			text=$(fn_status_info '/<status>/' '/<user>/' '<text>')
		else
			usage number
		fi

		url=$(echo $text | fn_url)

		if echo $url | grep ' ' 1>/dev/null 2>&1 ; then
			select i in $url ; do
				url=$i && break
			done
		fi

		[[ -z $url ]] && echo 'No URL' || eval $browser $url
		exit 1;;
	# TODO FLAG ??
	*)	fn_prepare_auth # Because there's no ${param[0]} (unless it's a '+')
		last_stat=$(sed -n "1p" $last_file 2>/dev/null)
		[[ ${param[0]} = '+' || ! -n $last_stat ]] && last_stat=1

		#data="$site/$api/friends_timeline.xml$data_par"
		# XXX: If $key_num is used, $tmp_file is overwritten, but it shouldn't
		# because, e.g., it will lose references for replies.

		if [[ $auth = oauth ]] ; then
			fn_oauth_params 'since_id' "$last_stat" 'count' "$opt_max_stats"
			fn_auth_header GET $site/$api/home_timeline.xml
			curl_extra_opts="-G -H \"$auth_header\""
		fi

		fn_download file $site/$api/home_timeline.xml \
		  "since_id=$last_stat" "count=$opt_max_stats"
		if [[ ${param[0]} != $key_number ]] ; then
			fn_last_status 1
		else
			grep -c '<status>' $tmp_file ; exit
		fi ;;
esac

fn_extract | fn_ol_list | fn_format | less $opt_pager_opts
