#!/usr/bin/env bash

# Qataki is free and unencumbered public domain software. For more
# information see http://unlicense.org/ or the accompanying UNLICENSE file.

# You can modify default options in $conf_file ($HOME/.qataki/qataki.conf)

usage() {
case $1 in
	file_miss)
		echo 'File is either non-existent or its size is 0.'
		exit 1 ;;
	empty)
		echo 'Forgot an option?'
		exit 1 ;;
	no_alias)
		echo "Alias is not configured in $conf_file"
		exit 1 ;;
	no_both)
		echo "Can't have both"
		exit 1 ;;
	no_auth)
		echo "Have you set up $conf_file correctly? Try \"$(basename $0) k\""
		exit 1 ;;
	no_impl)
		echo "Not implemented"
		exit 1 ;;
	number)
		echo "That option needs a number <= $opt_max_stats"
		exit 1 ;;
	invalid_paste)
	cat <<EOB
		Invalid paste string or an invalid file.
		Valid string examples: %%syntax:file or %%file
		If "file" is an image, it should have jpg, png or gif extension.
		"syntax" is optional: if present it's the language of "file" and
		can be one of those listed here: http://pastebin.com/api.php.
		If paste string is OK, then there is something wrong with "file".
EOB
		exit 1 ;;
	*)
		# It used to be cleaner, but configurable keys were added...
		# At least it shows OK on console.
		cat <<EOH

$(basename $0) [i|t|s:<SITE>] [n:<NICK>] [<OPTION> [<ARGUMENT>]]

The first (optional) flag can be: i (identi.ca) OR t (twitter) or
s:<SITE> (see below). If none of of these three flags are given,
then Identi.ca will be used. It is possible to use only 1 OPTION
and, eventually, its ARGUMENT. If no option is passed, messages
from people you follow will be retrived by default.
Options have a default value, but it is possible to modify defaults
by adding/changing key_*=OPTION in $conf_file (defaults after RESULT).

OPTION    ARGUMENT           RESULT

          [+]                Retrive messages from people you follow.
                             If you use the optional "+" argument, all statuses
                             will be displayed. Otherwise only new statuses.
$key_public                            Retrive messages from public timeline.
                             Default: key_public=p
$key_group         <GROUP>            Retrive messages from <GROUP timeline.
                             Default: key_group=g
$key_update         "message"          Update your status with a "message".
                             Default: key_update=u
$key_update_w                            Type a message interactively and update status
                             (end message with ^D (that is Control-d)).
                             Default: key_update_w=U
$key_mentions         [+]                Show notices where you are mentioned (@you).
                             If you use the optional "+" argument, all statuses
                             will be displayed. Otherwise only new statuses.
                             Default: key_mentions=m
$key_reply         <NUMBER> "message" Reply to message number <NUMBER>.
                             Default: key_reply=r
$key_context         <NUMBER>           Show conversation relative to notice <NUMBER>.
                             Default: key_context=c
$key_alt_nick:<NICK>  <OPTION>           Use an alternate nick. This option can be
                             preceded by [i|t|s:<SITE>] (i by default).
                             Default: key_alt_nick=n
$key_user         <USER>             Show <USER>'s timeline (last statuses).
                             Default: key_user=N
$key_prev                            Show previous (last) messages.
                             Default: key_prev=P
$key_details         <NUMBER>           Show details about notice <NUMBER> (note that
                             short links will be replaced by real links).
                             Default: key_details=d
$key_sn:<SITE>  <OPTION>           Use <OPTION> (exept s itself) on <SITE>.
                             Default: key_sn=s
$key_configure                            Configure an account.
                             Default: key_configure=k
$key_search         "string"           Search messages with "string".
                             Default: key_search=S
$key_resend         <NUMBER>           Retweet/redent message number <NUMBER>.
                             Default: key_resend=R
$key_comment         <NUMBER> [message] Retweet/redent message number <NUMBER>. The option
                             differs from the previous because you can:
                             1) Optionally add a message before resent message;
                             2) Transforms groups tags in hashtags (available
                                only for Identi.ca/StatusNet sites).
                             Technically, this option generates a reply.
                             Default: key_comment=C
$key_dir_msg_send         <USER> "message"   Send a direct msg (with text "message") to <USER>.
                             Default: key_dir_msg_send=M
$key_follow         <USER>|<NUMBER>    Follow someone (AKA subscribe).
                             Default: key_follow=f
$key_unfollow         <USER>|<NUMBER>    Unfollow someone (AKA unsubscribe).
                             Default: key_follow=F
$key_join         <GROUP>            Join <GROUP>.
                             Default: key_join=j
$key_unjoin         <GROUP>            Unjoin <GROUP>.
                             Default: key_unjoin=J
a         <NUMBER>           Add notice <NUMBER> to favorites list.
                             Default: key_like=a
o         <NUMBER>           Open a link present in notice <NUMBER> in your
                             \$BROWSER. If more than 1 link is present, a menu
                             to choose from will be displayed.
                             Default: key_open=o


NOTES:

"message" is the message/status you want to send. Enclose it in single or
          double quotes. (Remember to escape them if you use them in your
          message: "It's \\"my message\\"" or 'It\\'s "my message"'.
          It's possible to include a pastebin link or a link with a thumbnail
          of an image in your message. If you want to upload, for instance, a
          shell file and inlude it's link in the message include it like:
          "A shell script: %%bash:file.sh".
          It will be replaced by "A shell script: http://pastebin.com/example".
          If "file" is an image (jpg, png or gif), it will be uploaded to
          omploader.org and a link for the image will appear in the message:
          "A photo: %%file.png".
          It will be replaced by "A photo: http://omploader.org/example".
          The general "paste string" is %%syntax:file or %%file. In the former
          case the paste will be highlighted according to syntax. Available
          syntaxes are shown here: http://pastebin.com/api.php
<NUMBER>  is the tweet/dent number displayed on the left when you run
          "$(basename $0) [i|t|s<SITE>] [n:<NICK>] [N <USER>]".
<GROUP>   is the name of a Identi.ca/StatusNet group.
<NICK>    is an alternate nickname. You have to pass *alternate* nicknames
          on the command line as n:<NICK>. On the contrary, you don't have
          to specify your *default* nickname. For this, your default nick
          has to be placed in $conf_file. This is done by default when
          you use the "k" option. Anyway, the syntax for default nicks is:

          default_user_SERVICE=YOUR_DEFAULT_NICK

          where "SERVICE" can be identica, twitter or <SITE> (see below)
          and YOUR_DEFAULT_NICK is... your default nick on SERVICE.
<USER>    is a user's nickname (AKA screen_name; no spaces).
<SITE>    is an alias for a StatusNet compatible site. This alias is
          the second field of a line on $conf_file structured like:

          site ALIAS http://micro.example.com

          You'll be able to use ALIAS as argument for "s" option, like:

          "$(basename $0) s:ALIAS [n:<NICK>]".

          (with the latter example you'll see notices from people you
          follow on http://micro.example.com). For convevience, try to keep
          ALIAS short.

Authorisation is handled by curl with it's "-n" option. This means that a
.netrc file (located in \$conf_dir) is used. Qataki generates .netrc dinamically
when it's run (a 0077 umask is used). When it exits .netrc is restored.

When you run qataki with the "k" option, you can add your username and password
to $conf_file. If you ever need to do it by hand, its syntax is:

machine SERVICE login YOU password PASS

where SERVICE can be identi.ca OR twitter.com (and api.twitter.com) OR
a StatusNet compatible microblogging site (without "http://").

EOH
	exit 1 ;;
esac
}

# You will notice that curl is called as /usr/bin/env HOME=$conf_dir curl ...
# This is a security feature (thanks to Svend at Super Dimension Fortress).
# This way it's possible to create .netrc in $conf_dir ($HOME/.qataki/.netrc)
# so that we don't mess up the real .netrc (in $HOME/.netrc).

conf_dir=$HOME/.qataki
conf_file=$conf_dir/qataki.conf
cache_dir=$conf_dir/cache
tmp_file=$cache_dir/tmp
kill_file=$conf_dir/killfile
twitter=http://twitter.com
identica=http://identi.ca

umask 0077

fn_configuration() {
	echo "Create/modify account? [Y/n]"
	read -n 1 ans && echo
	[[ $ans = [nN]* ]] && echo 'Nothing done!' && exit 1

	echo >> $conf_file

	select i in Identi.ca Twitter StatusNet ; do
		[[ $REPLY != [123] ]] && continue
		case $REPLY in
			1|2) if [[ $REPLY -eq 1 ]] ; then
				v_site=identi.ca v_site_name=identica
				else
					v_site=twitter.com v_site_name=twitter
				fi ;;
			3)	while [[ -z $v_site ]] ; do
					echo "StatusNet site (e.g., http://micro.example.com):"
					read v_site
				done
				while [[ -z $v_site_name ]] ; do
					echo "Choose an alias for $v_site (a short alphanum word)"
					read v_site_name
					if [[ $v_site_name = *[!a-zA-Z0-9]* ]] ; then
						echo "Alphanumeric! Try again." && exit 1
					fi
				done

				v_site_full=$v_site
				v_site=${v_site/http:\/\/} ; v_site=${v_site%/}
		esac

		[[ $REPLY -le 3 ]] && break
	done

	echo "Configuring $i"

	while [[ -z $v_nick ]] ; do
		echo "Nickname:"
		read v_nick
	done

	while [[ -z $v_pass ]] ; do
		echo "Password:"
		read v_pass
	done

	echo "Is $v_nick your default $v_site account? [Y/n]"
	read -n 1 ans && echo
	if [[ $ans != [nN] ]] ; then
		if grep default_user_$v_site_name 1>/dev/null $conf_file ; then
			echo "You already had a default $v_site account."
		else
			echo "default_user_$v_site_name=$v_nick" >> $conf_file
		fi
	else
		if ! grep default_user_$v_site_name 1>/dev/null $conf_file ; then
			echo "You don't have a default $v_site account."
			echo "Run this configuration again with your default account first."
			exit 1
		fi
	fi

	if grep "machine $v_site login $v_nick" 1>/dev/null $conf_file ; then
		echo 'That account was already present. Nothing changed.'
	else
		echo "machine $v_site login $v_nick password $v_pass" >> $conf_file
		if [[ $v_site = 'twitter.com' ]] ; then # api.twitter.com *also* needed
			echo "machine api.$v_site login $v_nick password $v_pass" >> $conf_file
		fi

	fi

	[[ $REPLY -eq 3 ]] && echo "site $v_site_name $v_site_full" >> $conf_file

	echo "Done!"
	exit 0
}

[[ ! -d $cache_dir ]] && mkdir -p $cache_dir # Also $conf_dir
[[ ! -f $tmp_file ]] && > $tmp_file
if [[ ! -f $conf_file ]] ; then
	cat <<-EOC > $conf_file
		# These are options you can modify:
		opt_pager_opts='-REX' # Options for pager (less)
		opt_max_chars=140     # Max characters on update messages
		opt_max_stats=30      # Max number of statuses to display
		opt_editor=           # Options for your $EDITOR
		opt_order=default     # 'dafault' -> as website; 'date' -> chronological
		opt_show_date=0       # If = 1 dates will be displayed with statuses
		opt_kill=0            # If = 1 notices that contain strings from
		                      #        $kill_file will be grepped out
		opt_from=Qataki       # Change for whatever you like.
EOC
	fn_configuration
fi


# Default options. Can be changed in $conf_file
key_public=p key_update=u key_update_w=U key_mentions=m key_reply=r
key_user=N key_search=S key_context=c key_group=g key_resend=R key_details=d
key_dir_msg_send=M key_configure=k key_help=h key_Help=H key_prev=P
key_alt_nick=n key_sn=s key_follow=f key_unfollow=F key_join=j key_unjoin=J
key_delete=D key_like=a key_open=o key_comment=C key_block=b key_unblock=B

for i in $(grep -o "^\(key\|opt\)_[^ 	]*" $conf_file) ; do
	eval $i
done

opt_pager_opts=${opt_pager_opts:-'-REX'} opt_max_chars=${opt_max_chars:-140}
opt_max_stats=${opt_max_stats:-30} opt_order=${opt_order:-default}
opt_from=${opt_from:-Qataki} opt_show_date=${opt_show_date:-0}
opt_kill=${opt_kill:-0}

site=$identica api=api/statuses last_file=$cache_dir/last.dent
[[ $1 = i ]] && shift

if [[ $1 = $key_alt_nick:* ]] ; then
	my_nick=$1 my_nick=${my_nick/n:}
	last_file=$last_file.$my_nick
	shift
else
	my_nick=$(sed -n "s/^default_user_identica=//p" $conf_file)
fi

if [[ $1 = t ]] ; then
	site=$twitter api=statuses last_file=$cache_dir/last.tweet
	if [[ $2 = $key_alt_nick:* ]] ; then
		my_nick=$2 my_nick=${my_nick/n:}
		last_file=$last_file.$my_nick
		shift
	else
		my_nick=$(sed -n "s/^default_user_twitter=//p" $conf_file)
	fi
	shift
fi

if [[ $1 = $key_sn:* ]] ; then
	# Identi.ca is not present inside [[ ]] as it's the default value
	# and will be overwritten anyway is "s:..." is specified
	[[ $site = *twitter* ]] && usage no_both
	site_alias=$1 site_alias=${site_alias/s:}
	if [[ -z $2 ]] ; then
		usage empty
	else
		[[ ! $(grep "site $site_alias " $conf_file) ]] && usage no_alias
		if [[ $2 = $key_alt_nick:* ]] ; then
			my_nick=$2 my_nick=${my_nick/n:}
			last_file=$last_file.$my_nick
			shift
		else
			my_nick=$(sed -n "s/^default_user_$site_alias=//p" $conf_file)
		fi
	fi
	site=$(awk '/^site(\t| )+'$site_alias'/ {print $3}' $conf_file)
	last_file=$cache_dir/last.$site_alias
	shift
fi

# $last_file is 3 lines, where last statuses ids will be placed
[[ ! -f $last_file ]] && printf "\n\n\n" > $last_file

site=${site%/} # Be sure to leave out trailing slash
cols=$(( $(tput cols) - 2 ))
[[ $cols -le 10 ]] && cols=78 # If 'tput cols' fails
if which par 1>/dev/null ; then
	par_exe=1
	b_cols=300 # Columns for $BROWSER. Note that it's not $cols
else
	b_cols=$cols
fi

sort=sort # If gsort is present, we are on BSD and need gsort:
if which gsort 1>/dev/null ; then
	sort=gsort
fi

if which elinks 1>/dev/null ; then
	browser=${BROWSER:-elinks}
	render="elinks -dump -dump-width \$b_cols -eval 'set document.browse.margin_width = 1' -force-html -no-numbering -no-references"
else
	browser=${BROWSER:-lynx}
	# There's a -nomargins option, but it's less readable
	render="lynx -dump -width \$b_cols -force_html -stdin -display_charset=utf-8 -nonumbers -hiddenlinks=ignore -nolist"
fi

# Valid characters for for #hashes, @users, !groups
chars='a-zA-Z0-9_-'

# Embed colour sequences
col_emph='[1;33;40m'
col_foll='[0;30;43m'
col_norm='[0m'
col_link='[1;36;40m'
col_at='[1;35;40m'
col_hash='[1;32;40m'
col_bang='[1;31;40m'

# When local function's $1 is 'filter', more passages are needed
fn_download() {
	{ if [[ "$1" != filter ]] ; then
		/usr/bin/env HOME=$conf_dir curl -f -s -n "$data" > $tmp_file
	else
		/usr/bin/env HOME=$conf_dir curl -f -s -n --data-urlencode "q=$string" "$data" | \
		  sed '1,/<status>/ { /Search/d ; };
		  s@<\(/*\)title>@<\1text>@g;s@<\(/*\)entry>@<\1status>@g;
		  s@<name>\([^< ][^< ]*\).*</name>@<screen_name>\1</screen_name>@' \
		  > $tmp_file
	fi ; } || exit 1

	# A file <= 3 lines (always sufficient?) is a file with an error
	[[ $(wc -l < $tmp_file) -gt 3 ]] && return || exit 2
}

# First, remove tags with sed and put contents on a line. Then, search
# for tags of interest with awk, put them in a variable, and show them
# in specific order when a defined tag is reached. I know the awk stuff
# is a bit ugly ;) I'll change it, some day...
fn_extract() {
sed '/<retweeted_status>/,/<\/retweeted_status>/ !{
s@\(>*\)\([^<>]*\)\(<*\)@\1\
\2\
\3@g
}' $tmp_file | sed '/^$/d;/[<>]/d' | \
awk -v show_date=$opt_show_date \
  ' /^(screen_name)|(text)|(in_reply_to_screen_name)|(following)|(created_at)$/,/^(\/screen_name)|(\/text)|(\/in_reply_to_screen_name)|(\/following)|(\/created_at)$/ {
if ( $1 ~ /^screen_name$/ ) { sn=1 ; next }
if ( $1 ~ /^following$/ ) { foll=1 ;  next }
if ( $1 ~ /^text$/ ) { txt=1 ; next }
if ( $1 ~ /^in_reply_to_screen_name$/ ) { rep=1 ; next }
if ( $1 ~ /^created_at$/ ) {
	if (status_date == "") { date=1 ; next } else { next } }
if ( $1 ~ /^\/screen_name$/ ) { sn=0 ; next }
if ( $1 ~ /^\/text$/ ) { txt=0 ;  next }
if ( $1 ~ /^\/in_reply_to_screen_name$/ ) { rep=0; next }
if ( $1 ~ /^\/following$/ ) { foll=0 ; next }
if ( $1 ~ /^\/created_at$/ ) { date=0 ;  next }
if ( sn == 1 ) { sn_content=sn_content $0 }
if ( txt == 1 ) { txt_content=txt_content $0 }
if ( rep == 1 ) { rep_content=rep_content $0 }
if ( foll == 1 ) { foll_mark=$0 }
if ( date == 1 ) { status_date=$0 }
}
/^\/status$/ {
if ( show_date == 1 ) { txt_content=txt_content " [" status_date "]" }
if (rep_content) { txt_content=txt_content " {context}" }
if (foll_mark=="true") { foll_mark="###" } else { foll_mark="" }
print "*" foll_mark sn_content "*: " txt_content
txt_content=""; sn_content=""; rep_content=""; status_date=""
}'
}

# An attempt to support conversations. Should be rewritten when API
# has method for conversations. Basically, the page with the main
# notice is downloaded (passed with $1) and formatted.
fn_conversation() {
	curl -s "$1" | \
	  sed -n '/<div id="content">/,/<div id="aside_primary"/ p' | \
	  sed '/<img src=/d;s/<p class=/<span class=/;s@</p>@</span>@;
	    s@\(<span class="nickname fn">\)\(.*\)\(</span>\)@\1*\2*: \3@'
}

# Return an ordered list for notices: # <ol><li>Notice 1<li>Notice 2..</ol>
fn_ol_list() {
	if [[ $par_exe -ne 1 ]] ; then
		awk 'BEGIN { print "<ol>" } { print "<li>" $0 } END { print "</ol>" } '
	else
		if [[ $opt_order = date ]] ; then
			awk '{ print NR ".", $0 "<br>" }' | $sort -nr
		else
			awk '{ print NR ".", $0 "<br>" }'
		fi
	fi | \
	if [[ $opt_kill = 1 && -s $kill_file ]] ; then
		grep -v -f $HOME/.qataki/killfile
	else
		cat - # UUOC ?!?!?
	fi
	#awk 'BEGIN { print "<ol>" } { print "<li>" $0 } END { print "</ol>" } '
}


# Links are searched in a way that http, ftp and gopher are valid links.
fn_format() {
	# If called with a parameter 'par' won't be used (see e.g., "conversation")
	# B+_x5D_x7D means "add ']' and '}' as body characters".
	if [[ -z $1 && $par_exe -eq 1 ]] ; then
		eval $render | par B+_x5D_x7D ${cols}p5dh
	else
		eval $render
	fi | \
	sed "s/^\([^1-9]*[1-9][0-9]*\.[^\*]*\)\*###\([^ ][^ ]*\)\*:/\1$col_foll\2$col_norm:/;\
	  s/^\([^1-9]*[1-9][0-9]*\.[^\*]*\)\*\([^ ][^ ]*\)\*:/\1$col_emph\2$col_norm:/;\
	  s@\([fgh][a-zA-Z]*://[^ ][^ ]*[a-zA-Z0-9/]\)@$col_link\1$col_norm@g;\
	  s/\(@[$chars][$chars]*\)/$col_at\1$col_norm/g;\
	  s/\(#[$chars][$chars]*\)/$col_hash\1$col_norm/g;\
	  s/\(![$chars][$chars]*\)/$col_bang\1$col_norm/g;\
	  s/\({context}\)$/[1m\1[0m/"
}

fn_details() {
answ=$1 # This variable is always the notice (twit/dent) number.

status_start=$(sed -n '/<status>/=' $tmp_file | sed -n ${answ}p)
status_end=$(sed -n '/<\/status>/=' $tmp_file | sed -n ${answ}p)

sed 's/&lt;/</g;s/&gt;/>/g;s/&quot;/"/g' $tmp_file | \
sed -n "$status_start,$status_end {
s@<text>\([^<]*\)<*.*@<li>Status: \1@p
# Sometimes a status can have a new line:
s@^[[:space:]][[:space:]]*[^<[:space:]]\([^<][^<]*\)<*/.*@\1@p
s@<screen_name>\(.*\)</screen_name>@<li>Nick: \1@p
s@<name>\(.*\)</name>@<li>Name: \1@p
s@<location>\(.*\)</location>@<li>Location: \1@p
s@<url>\(.*\)</url>@<li>URL: \1@p
/<status>/,/<user>/ {
s@<created_at>\(.*\)</created_at>@<li>Date: \1@p
s@<source>\(.*\)</source>@<li>From: \1@p
}
}" | fn_real_urls | fn_format

}

# Search for the first <id> and assign its value to $last. (Even if
# both <status> and <user> have an <id>, <status> always comes first.)
# Then, update $last file with this new value.
# The argument passed to this function is the kind of <id> on which we
# we are interested on: 1 => home_timeline; 2 => mentions
fn_last_status() {
last=$(sed -n '/<id>/p' $tmp_file | \
  sed -n '1s@[[:space:]]*<id>\([^<]*\)</id>@\1@p')
sed "$1 c\\
$last
" $last_file > $last_file.tmp
mv $last_file.tmp $last_file
}

# Prints URLs. XXX: gopher? ftp?
fn_url() {
	awk '{
	url_re = "https?://"
	for (i=1; i<=NF; i++) {
			if (match($i, url_re)) { print $i }
	}}'
}

# Extract title from URL ($1).
# Original idea by @ksaver http://identi.ca/ksaver
fn_url_title() {
	curl -s "$1" | awk 'BEGIN { ORS=" " }
	  /<[Tt][Ii][Tt][Ll][Ee]>/,/<\/[Tt][Ii][Tt][Ll][Ee]>/ { print $0 }' | \
	sed 's@.*<[Tt][Ii][Tt][Ll][Ee]>\(.*\)</[Tt][Ii][Tt][Ll][Ee]>.*$@\1@'
}

# This will output HTTP header field "Location".
# So, give this function a short URL, and will ourput real URL.
fn_real_urls() {
	awk ' BEGIN { ORS=" " }
	/Status:/ {
	url_re = "http://[^ ]+"
	for (i=1; i<=NF; i++) {
		if (i==NF) { ORS="\n" }
		x=$i
		if (match($i, url_re)) {
			"curl -s -I \""$i"\" | sed -n \"s@Location: \\(.*\\)@\\1@p\"" | \
			  getline x
			print x
		} else { print x }
	} }
	!/Status:/ { print }
	'
}

fn_editor_update() {
	editor=${EDITOR:-vi}
	tmp_status=${TMP:-/tmp}/qataki_$(id -u).$$
	> $tmp_status
	eval $editor $opt_editor $tmp_status
	message=$(tr '\n' ' ' < $tmp_status)
	rm $tmp_status
}

fn_prepare_auth() {
	site_name=${site/*:\/\/}

	# \(api.\)\?... shuld match api.twitter.com, so \(api.\)*...
	grep "machine \(api.\)*$site_name login $my_nick" $conf_file \
	  > $conf_dir/.netrc

	# Check that site (without http[s]://) is in .netrc
	[[ -z $(grep $site_name $conf_dir/.netrc 2>/dev/null) ]] && usage no_auth
}

fn_status_info() {
	delim_1="$1" delim_2="$2" tag_o="$3" tag_c="</${tag_o#<}"
	sed -n "/<retweeted_status>/,/<\/retweeted_status>/ !{
	$delim_1,$delim_2 {
	  /$tag_o/ p
	}
	}" $tmp_file | sed -n "$status_num s@.*$tag_o\($tag_cont_re*\)$tag_c@\1@p"
}

fn_paste() {
	paste_string=$(echo "$msg" | sed 's/[^%]*%%\([^ ]*\).*/\1/')
	# $syntax shouldn't be done with ${paste_string%:*}
	syntax=$(echo $paste_string | sed -n 's/\([^:][^:]\):.*/\1/p')
	file=${paste_string#*:}
	file_ext=$(echo ${file#*.} | tr '[A-Z]' '[a-z]')
	[[ ! -s $file ]] && usage file_miss
	[[ -n $syntax ]] && extra_paste="-d paste_format=$syntax"

	case $file_ext in
		jp*g|png|gif) # Upload file to omploader.org and return URL
			paste=$(curl -s -F "file1=@$file" http://omploader.org/upload | \
			  sed -n '/ file:/ s/.*\(http[^<]*\).*/\1/p') ;;
		*) # Otherwise use pastebin.com
			paste=$(curl -s $extra_paste --data-urlencode "paste_code@$file" \
			  http://pastebin.com/api_public.php) ;;
	esac

	if echo "$paste" | grep ' ' 1>/dev/null 2>&1 ; then
		usage invalid_paste
	else
		msg=$(echo "$msg" | sed "s@\([^%]*\)%%[^ ]*\(.*\)@\1${paste}\2@")
	fi
}

# For auth we will generate a new .netrc site, after moving the old one.
# When the scripts exits, restore .netrc (a sane umask was already set):
trap "rm -f $conf_dir/.netrc" EXIT

read parameters_line <<< $(echo " $@") # XXX portability :(
while read -t 0.1 line ; do # XXX again :((
	parameters_pipe="$parameters_pipe $line"
done

parameters="$parameters_line $parameters_pipe"

for i in $parameters ; do
	param[${#param[@]}]=$i
done

fn_parameters() {
	for (( i=$1 ; i<$2 ; i++ )) ; do
		last_param="$last_param ${param[$i]}"
	done
	echo ${last_param# }
}

# Options that need authentication
[[ ${param[0]} = *[$key_update$key_update_w$key_reply$key_mentions$key_sn$key_resend\
$key_dir_msg_send$key_delete$key_follow$key_unfollow$key_join$key_unjoin\
$key_like$key_comment$key_block$key_unblock] ]] && fn_prepare_auth

# XXX: 1) Rewrite options parsing. 2) Make $site/$api etc. better.
case ${param[0]} in
	*$key_public)	data="$site/$api/public_timeline.xml?count=$opt_max_stats"
		fn_download ;;
	*$key_update) msg=$(fn_parameters 1 ${#param[@]})
		if echo "$msg" | grep '%%' 1>/dev/null 2>&1 ; then
			fn_paste
		elif echo "$msg" | grep '^http[^ ]*' 1>/dev/null 2>&1 ; then
			link_title=$(fn_url_title $msg)
			msg="$link_title $msg"
		fi
		/usr/bin/env HOME=$conf_dir curl -s -n -d "source=$opt_from" \
		  --data-urlencode "status=$msg" $site/$api/update.xml 1>/dev/null
		exit 0 ;;
	*$key_update_w) message= ; fn_editor_update
		/usr/bin/env HOME=$conf_dir curl -s -n -d "source=$opt_from" \
		  --data-urlencode "status=$message" $site/$api/update.xml 1>/dev/null
		exit 0 ;;
	*$key_mentions)
		if [[ ${param[1]} != '+' && -f $last_file ]] ; then
			last_stat=$(sed -n "2p" $last_file)
			[[ $last_stat = *[0-9]* ]] || last_stat=1
		fi
		data_par="since_id=${last_stat}&count=$opt_max_stats"
		data="$site/$api/mentions.xml?$data_par"
		fn_download && fn_last_status 2 ;;
	*$key_reply|*$key_comment)
		message=$(fn_parameters 2 ${#param[@]})
		[[ -z ${param[1]} || ${param[1]} = *[!0-9]* ]] && { echo 'Select a number' && exit 1 ; }

		status_num=${param[1]} tag_cont_re='.'
		reply_to=$(fn_status_info '/<status>/' '/<user>/' '<id>')
		user_name=$(fn_status_info '/<user>/' '/<status>/' '<screen_name>')
		if [[ ${param[0]} = $key_comment ]] ; then
			comment=$(fn_status_info '/<status>/' '/<user>/' '<text>' | \
			  sed 's/!\([^[:space:]][^[:space:]]*\)/#\1/g')
			[[ $site = *twitter* ]] && resend=RT || resend=RD
			reply_status="$message $resend @$user_name $comment"
		else
			[[ -z $message ]] && { echo 'Message?' ; exit 1 ; }
			reply_status="@$user_name $message"
		fi

		# XXX: @file is recognised by curl. Problems?
		/usr/bin/env HOME=$conf_dir curl -s -n -d "source=$opt_from" \
		  --data-urlencode "status=${reply_status# }" \
		  -d "in_reply_to_status_id=$reply_to" $site/$api/update.xml 1>/dev/null
		exit 0 ;;
	*$key_user) [[ "$site" == *twitter* ]] && site=http://api.twitter.com/1
		nick=${param[1]}
		data="$site/$api/user_timeline.xml?screen_name=${nick}&count=$opt_max_stats"
		fn_download ;;
	*$key_search)
		if [[ "$site" == *twitter* ]] ; then
			site=http://search.twitter.com
		else
			site=$identica/api
		fi
		string=$(fn_parameters 1 ${#param[@]})
		data="$site/search.atom?rpp=$opt_max_stats"
		fn_download filter ;;
	*$key_context) [[ "$site" == *twitter* ]] && usage no_impl
		# Retrive conversation URL from status id
		b_cols=$cols
		status_num=${param[1]} tag_cont_re='.'
		context_id=$(fn_status_info '/<status>/' '/<user>/' '<in_reply_to_status_id>')
		conversation_url=$(curl -L -s "$site/notice/$context_id" | \
		  sed -n "/>in context</ { s/[^\"]*\"\([^#]*\).*/\1/ p
		    }")
		# Format conversation
		fn_conversation "$conversation_url" | fn_format conversation | \
		  sed "/^$/d;s/ \{10\}/        $col_emph|$col_norm/g" | \
		  sed "s/ \{5\}/  $col_hash|$col_norm/g" | \
		  less $opt_pager_opts
		  exit 0 ;;
	*$key_group|*$key_join|*$key_unjoin)
		[[ "$site" == *twitter* ]] && usage no_impl
		group=${param[1]}
		api=api/statusnet
		if [[ ${param[0]} = *$key_group ]] ; then
			data="$site/$api/groups/timeline.xml?id=$group&count=$opt_max_stats"
			fn_download
		else
			[[ ${param[0]} = *$key_join ]] && kind=join || kind=leave
			data="$site/$api/groups/$kind/$group.xml"
			/usr/bin/env HOME=$conf_dir curl -X POST -f -s -n "$data" \
			  1>/dev/null && exit 0
		fi ;;
	*$key_resend|*$key_delete|*$key_like)
		if grep '<feed ' $tmp_file 1>/dev/null ; then
		re1='$' re2=':' # This case is when file returned is Atom
		else
			re1='/<user>/' re2='<id>' # This is normal case (e.g., API)
		fi

		status_num=${param[1]} tag_cont_re='.'
		notice_id=$(fn_status_info '/<status>/' "$re1" "$re2")

		if [[ "$site" == *twitter* ]] ; then
			site=http://api.twitter.com/1
		fi

		if [[ ${param[0]} = *$key_like ]] ; then
			[[ "$site" == *twitter* ]] && api=favorites || api=api/favorites
			kind=create
		else
			[[ ${param[0]} = *$key_resend ]] && kind=retweet || kind=destroy
		fi

		/usr/bin/env HOME=$conf_dir curl -f -s -n -X POST \
		  -d "source=$opt_from" \
		  "$site/$api/$kind/$notice_id.xml" 1>/dev/null
		exit 0 ;;
	*$key_dir_msg_send) to_user=${param[1]} # XXX: FIX URL
		[[ $to_user = *[!a-zA-Z0-9]* ]] && { echo 'username is alphanum' ; exit 1 ; }
		[[ -n ${param[2]} ]] && dir_msg=$(fn_parameters 2 ${#param[@]}) || { echo 'Enter a message' ; exit 1 ; }
		[[ "$site" == *twitter* ]] && unset api
		/usr/bin/env HOME=$conf_dir curl -n -X POST -d "source=$opt_from" \
		  --data-urlencode "user=$to_user" --data-urlencode "text=$dir_msg" \
		  "$site/api/direct_messages/new.xml" 1>/dev/null
		echo "$site/api/direct_messages/new.xml"
		exit 0 ;;
	*$key_details)
		grep '<verified>' $tmp_file 1>/dev/null || site=$identica # verif -> tw
		fn_details ${param[1]} && exit 0 ;;
	*$key_configure)	fn_configuration ;;
	*$key_help|*$key_Help) usage ;;
	*$key_prev) : ;; # Do nothing: Messages are already in $tmp_file
	*[$key_follow$key_unfollow$key_block$key_unblock])
		# XXX: block API issues.
		[[ ${param[0]} = [$key_follow$key_unfollow] ]] && api=friendships || api=blocks
		if [[ "$site" == *twitter* ]] ; then
			site=http://api.twitter.com/1
		else
			api=api/$api
		fi

		[[ ${param[0]} = *[$key_follow$key_block] ]] && kind=create || kind=destroy

		if [[ ${param[1]} != *[a-zA-Z]* && ${param[1]} -le $opt_max_stats ]] ; then
			# It's a number and probably not a username
			status_num=${param[1]} tag_cont_re='.'
			user=$(fn_status_info '/<user>/' '/<\/user>/' '<id>')
			data_par="user_id=$user"
		else
			user=${param[1]}
			data_par="screen_name=$user"
		fi
		data="$site/$api/$kind.xml?$data_par"
		/usr/bin/env HOME=$conf_dir curl -s -X POST -n "$data" 1>/dev/null
		exit 0 ;;
	*$key_open)
		if [[ ${param[1]} != *[a-zA-Z]* && ${param[1]} -le $opt_max_stats ]] ; then
			status_num=${param[1]} tag_cont_re='.'
			# If there's a NL it won't take all the text.
			text=$(fn_status_info '/<status>/' '/<user>/' '<text>')
		else
			usage number
		fi

		url=$(echo $text | fn_url)

		if echo $url | grep ' ' 1>/dev/null 2>&1 ; then
			select i in $url ; do
				url=$i && break
			done
		fi

		[[ -z $url ]] && echo 'No URL' || eval $browser $url
		exit 1;;
	# TODO FLAG ??
	*)	fn_prepare_auth # This is because there's no ${param[0]} (unless it's a '+')
		last_stat=$(sed -n "1p" $last_file 2>/dev/null)
		[[ ${param[0]} = '+' || ! -n $last_stat ]] && last_stat=1

		data_par="since_id=${last_stat}&count=$opt_max_stats"
		#data="$site/$api/friends_timeline.xml$data_par"
		data="$site/$api/home_timeline.xml?$data_par"
		fn_download && fn_last_status 1 ;;
esac

fn_extract | fn_ol_list | fn_format | less $opt_pager_opts
