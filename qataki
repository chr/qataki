#!/usr/bin/env bash

# Qataki is free and unencumbered public domain software. For more
# information see http://unlicense.org/ or the accompanying UNLICENSE file.


opt_pager='-REX' 	# Options for pager (less)
max_chars=140		# Max characters on update messages
max_stats=30		# Max number of statuses to display

# Not used yet
qataki_url="&lt;a href='http://chr.tx0.org/qataki' alt='Qataki' title='Qataki'&gt;qataki&lt;/a&gt;"

usage() {
case $1 in
	file_miss)
		echo "File is either non-existent or its size is 0."
		exit 1 ;;
	empty)
		echo "Forgot an option?"
		exit 1 ;;
	no_alias)
		echo "Alias is not configured in $conf_file"
		exit 1 ;;
	no_both)
		echo "Can't have both"
		exit 1 ;;
	no_exe)
		echo "$2 is not installed on your system"
		exit 1 ;;
	no_auth)
		echo "Have you set up $conf_file correctly? Try \"$(basename $0) k\""
		exit 1 ;;
	no_impl)
		echo "Not implemented"
		exit 1 ;;
	*)
		cat <<EOH

$(basename $0) [i|t|s:<SITE>] [n:<NICK>] [<OPTION> [<ARGUMENT>]]

The first (optional) flag can be: i (identi.ca) OR t (twitter) or
s:<SITE> (see below). If none of of these three flags are given,
then Identi.ca will be used. It is possible to use only 1 OPTION
and, eventually, its ARGUMENT.

OPTION    ARGUMENT         RESULT

f         [F]              Retrive messages from people you follow.
                           If you use the optional "F" argument, all statuses
                           will be displayed. Otherwise only new statuses.
u         "message"        Update your status with a "message".
U                          Type a message interactively and update status
                           (end message with ^D (that is Control-d)).
m         [F]              Show notices where you are mentioned (@you).
                           If you use the optional "F" argument, all statuses
                           will be displayed. Otherwise only new statuses.
r         <NUMBER>         Reply to message number <NUMBER>.
c         <NUMBER>         Show conversation relative to notice <NUMBER>.
n:<NICK>  <OPTION>         Use an alternate nick. This option can be
                           preceded by [i|t|s:<SITE>] (i by default).
N         <USER>           Show <USER>'s timeline (last statuses).
p                          Show previous messages.
d         <NUMBER>         Show details about notice <NUMBER> (note that
                           short links will be replaced by real links).
s:<SITE>  <OPTION>         Use <OPTION> (exept s itself) on <SITE>.
k                          Configure an account.
S         "string"         Search messages for "a string".
R        <NUMBER>          Retweet message number <NUMBER>.
D        <USER> "message"  Send a direct msg (with text "message") to <USER>.

NOTES:

<NUMBER>  is the tweet/dent number displayed on the left when you run
          "$(basename $0) [i|t|s<SITE>] [n:<NICK>] [f|N <USER>]".
<NICK>    is an alternate nickname. You have to pass *alternate* nicknames
          on the command line as n:<NICK>. On the contrary, you don't have
          to specify your *default* nickname. For this, your default nick
          has to be placed in $conf_file. This is done by default when
          you use the "k" option. Anyway, the syntax for default nicks is:

          default_user_SERVICE=YOUR_DEFAULT_NICK

          where "SERVICE" can be identica, twitter or <SITE> (see below)
          and YOUR_DEFAULT_NICK is... your default nick on SERVICE.
<USER>    is a user's nickname (AKA screen_name; no spaces).
<SITE>    is an alias for a StatusNet compatible site. This alias is
          the second field of a line on $conf_file structured like:

          site ALIAS http://micro.example.com

          You'll be able to use ALIAS as argument for "s" option, like:

          "$(basename $0) s:ALIAS [n:<NICK>] f".

          (with the latter example you'll see notices from people you
          follow on http://micro.example.com). For convevience, try to keep
          ALIAS short.

Authorisation is handled by curl with it's "-n" option. This means that a
.netrc file (located in \$HOME) is used. Qataki generates .netrc dinamically
when it's run (a 0077 umask is used). When it exits .netrc is restored.

When you run qataki with the "k" option, you can add your username and password
to $conf_file. If you ever need to do it by hand, its syntax is:

machine SERVICE login YOU password PASS

where SERVICE can be identi.ca OR twitter.com (and api.twitter.com) OR
a StatusNet compatible microblogging site (without "http://").

EOH
	exit 1 ;;
esac
}

conf_dir=$HOME/.qataki
conf_file=$conf_dir/qataki.conf
cache_dir=$conf_dir/cache
tmp_file=$cache_dir/tmp
twitter=http://twitter.com
identica=http://identi.ca

umask 0077

fn_configuration() {
	echo "Create/modify account? [Y/n]"
	read -n 1 ans && echo
	[[ $ans = [nN]* ]] && echo 'Nothing done!' && exit 1

	echo >> $conf_file

	select i in Identi.ca Twitter StatusNet ; do
		[[ $REPLY != [123] ]] && continue
		case $REPLY in
			1|2) if [[ $REPLY -eq 1 ]] ; then
				v_site=identi.ca v_site_name=identica
				else
					v_site=twitter.com v_site_name=twitter
				fi ;;
			3)	while [[ -z $v_site ]] ; do
					echo "StatusNet site (e.g., http://micro.example.com):"
					read v_site
				done
				while [[ -z $v_site_name ]] ; do
					echo "Choose an alias for $v_site (a short alphanum word)"
					read v_site_name
					if [[ $v_site_name = *[!a-zA-Z0-9]* ]] ; then
						echo "Alphanumeric! Try again." && exit 1
					fi
				done

				v_site_full=$v_site
				v_site=${v_site/http:\/\/} ; v_site=${v_site%/}
		esac

		[[ $REPLY -le 3 ]] && break
	done

	echo "Configuring $i"

	while [[ -z $v_nick ]] ; do
		echo "Nickname:"
		read v_nick
	done

	while [[ -z $v_pass ]] ; do
		echo "Password:"
		read v_pass
	done

	echo "Is $v_nick your default $v_site account? [Y/n]"
	read -n 1 ans && echo
	if [[ $ans != [nN] ]] ; then
		if grep default_user_$v_site_name 1>/dev/null $conf_file ; then
			echo "You already had a default $v_site account."
		else
			echo "default_user_$v_site_name=$v_nick" >> $conf_file
		fi
	else
		if ! grep default_user_$v_site_name 1>/dev/null $conf_file ; then
			echo "You don't have a default $v_site account."
			echo "Run this configuration again with your default account first."
			exit 1
		fi
	fi

	if grep "machine $v_site login $v_nick" 1>/dev/null $conf_file ; then
		echo 'That account was already present. Nothing changed.'
	else
		echo "machine $v_site login $v_nick password $v_pass" >> $conf_file
		if [[ $v_site = 'twitter.com' ]] ; then # api.twitter.com *also* needed
			echo "machine api.$v_site login $v_nick password $v_pass" >> $conf_file
		fi

	fi

	[[ $REPLY -eq 3 ]] && echo "site $v_site_name $v_site_full" >> $conf_file

	echo "Done!"
	exit 0
}

[[ ! -d $cache_dir ]] && mkdir -p $cache_dir # Also $conf_dir
[[ ! -f $tmp_file ]] && > $tmp_file
[[ ! -f $conf_file ]] && > $conf_file && fn_configuration

site=$identica api=api/statuses last_file=$cache_dir/last.dent
[[ $1 = i ]] && shift

if [[ $1 = n:* ]] ; then
	my_nick=$1 my_nick=${my_nick/n:}
	last_file=$last_file.$my_nick
	shift
else
	my_nick=$(sed -n "s/^default_user_identica=//p" $conf_file)
fi

if [[ $1 = t ]] ; then
	site=$twitter api=statuses last_file=$cache_dir/last.tweet
	if [[ $2 = n:* ]] ; then
		my_nick=$2 my_nick=${my_nick/n:}
		last_file=$last_file.$my_nick
		shift
	else
		my_nick=$(sed -n "s/^default_user_twitter=//p" $conf_file)
	fi
	shift
fi

if [[ $1 = s:* ]] ; then
	# Identi.ca is not present inside [[ ]] as it's the default value
	# and will be overwritten anyway is "s:..." is specified
	[[ $site = *twitter* ]] && usage no_both
	site_alias=$1 site_alias=${site_alias/s:}
	if [[ -z $2 ]] ; then
		usage empty
	else
		[[ ! $(grep "site $site_alias " $conf_file) ]] && usage no_alias
		if [[ $2 = n:* ]] ; then
			my_nick=$2 my_nick=${my_nick/n:}
			last_file=$last_file.$my_nick
			shift
		else
			my_nick=$(sed -n "s/^default_user_$site_alias=//p" $conf_file)
		fi
	fi
	site=$(awk '/^site(\t| )+'$site_alias'/ {print $3}' $conf_file)
	last_file=$cache_dir/last.$site_alias
	shift
fi

# $last_file is 3 lines, where last statuses ids will be placed
[[ ! -f $last_file ]] && printf "\n\n\n" > $last_file

site=${site%/} # Be sure to leave out trailing slash
cols=$(( $(tput cols) - 2 ))
[[ $cols -le 10 ]] && cols=78 # If 'tput cols' fails

if which elinks 1>/dev/null ; then
	render="elinks -dump -dump-width $cols -eval 'set document.browse.margin_width = 1' -force-html -no-numbering -no-references"
else
	# There's a -nomargins option, but it's less readable
	render="lynx -dump -width $cols -force_html -stdin -display_charset=utf-8"
fi

# Valid characters for for #hashes, @users, !groups
chars='a-zA-Z0-9_-'

# Embed colour sequences
col_emph='[1;33;40m'
col_norm='[0m'
col_link='[1;36;40m'
col_at='[1;35;40m'
col_hash='[1;32;40m'
col_bang='[1;31;40m'

# When local function's $1 is 'filter', more passages are needed
fn_download() {
	{ if [[ "$1" != filter ]] ; then
		curl -f -s -n "$data" > $tmp_file
	else
		curl -f -s -n --data-urlencode "q=$string" "$data" | \
		  sed '1,/<status>/ { /Search/d ; };
		  s@<\(/*\)title>@<\1text>@g;s@<\(/*\)entry>@<\1status>@g;
		  s@<name>\([^< ][^< ]*\).*</name>@<screen_name>\1</screen_name>@' \
		  > $tmp_file
	fi ; } || exit 1

	# A file <= 3 lines (always sufficient?) is a file with an error
	[[ $(wc -l < $tmp_file) -gt 3 ]] && return || exit 2
}

# First, remove tags with sed and put contents on a line. Then, search
# for tags of interest with awk, put them in a variable, and show them
# in specific order when a defined tag is reached.
fn_extract() {
sed '/<retweeted_status>/,/<\/retweeted_status>/ !{
s@\(>*\)\([^<>]*\)\(<*\)@\1\
\2\
\3@g
}' $tmp_file | sed '/^$/d;/[<>]/d' | \
awk ' /^(screen_name)|(text)|(in_reply_to_screen_name)$/,/^(\/screen_name)|(\/text)|(\/in_reply_to_screen_name)$/ {
if ( $1 ~ /^screen_name$/ ) { sn=1 ; next }
if ( $1 ~ /^text$/ ) { txt=1 ; next }
if ( $1 ~ /^in_reply_to_screen_name$/ ) { rep=1 ; next }
if ( $1 ~ /^\/screen_name$/ ) { sn=0 ; next }
if ( $1 ~ /^\/text$/ ) { txt=0 ;  next }
if ( $1 ~ /^\/in_reply_to_screen_name$/ ) { rep=0; next }
if ( sn == 1 ) { sn_content=sn_content $0 }
if ( txt == 1 ) { txt_content=txt_content $0 }
if ( rep == 1 ) { rep_content=rep_content $0 }
}
/^\/status$/ {
if (rep_content) { txt_content=txt_content " {context}" }
print "*" sn_content "*: " txt_content
txt_content=""; sn_content=""; rep_content=""
}'
}

# An attempt to support conversations. Should be rewritten when API
# has method for conversations. Basically, the page with the main
# notice is downloaded (passed with $1) and formatted.
fn_conversation() {
	curl -s "$1" | \
	  sed -n '/<div id="content">/,/<div id="aside_primary"/ p' | \
	  sed '/<img src=/d;s/<p class=/<span class=/;s@</p>@</span>@;
	    s@\(<span class="nickname fn">\)\(.*\)\(</span>\)@\1*\2*: \3@'
}

# Return an ordered list for notices: # <ol><li>Notice 1<li>Notice 2..</ol>
fn_ol_list() {
	awk 'BEGIN { print "<ol>" } { print "<li>" $0 } END { print "</ol>" } '
}

# Links are searched in a way that http, ftp and gopher are valid links.
fn_format() {
	eval $render | \
	sed "s/^\([^1-9]*[1-9][0-9]*\.[^\*]*\)\*\([^ ][^ ]*\)\*:/\1$col_emph\2$col_norm:/;\
	     s@\([fgh][a-zA-Z]*://[^ ][^ ]*[a-zA-Z0-9/]\)@$col_link\1$col_norm@g;\
		 s/\(@[$chars][$chars]*\)/$col_at\1$col_norm/g;\
		 s/\(#[$chars][$chars]*\)/$col_hash\1$col_norm/g;\
		 s/\(![$chars][$chars]*\)/$col_bang\1$col_norm/g"
}

fn_details() {
answ=$1 # This variable is always the notice (twit/dent) number.
full_notice=$($xml sel -t -m "/statuses/status[$answ]" \
 -o "User: " -v user/screen_name -n \
 -o "Text: " -v text -i "in_reply_to_user_id>0" -n \
 -o "Reply: $site/" -v in_reply_to_screen_name -o "/" -v in_reply_to_status_id \
 -b -n -o "Date: " -v created_at $tmp_file)

echo "$full_notice" | grep ^Text | fn_real_urls
echo "$full_notice" | grep -v ^Text
}

# Search for the first <id> and assign its value to $last. (Even if
# both <status> and <user> have an <id>, <status> always comes first.)
# Then, update $last file with this new value.
# The argument passed to this function is the kind of <id> on which we
# we are interested on: 1 => home_timeline; 2 => mentions
fn_last_status() {
last=$(sed -n '/<id>/p' $tmp_file | \
  sed -n '1s@[[:space:]]*<id>\([^<]*\)</id>@\1@p')
sed "$1 c\\
$last
" $last_file > $last_file.tmp
mv $last_file.tmp $last_file
}

# This will output HTTP header field "Location".
# So, give this function a short URL, and will ourput real URL.
fn_real_urls() {
	awk ' BEGIN { ORS=" " }
	{
	url_re = "http://[^ ]*"
	for (i=1; i<=NF; i++) {
		if (i==NF) { ORS="\n" }
		x=$i
		if (match($i, url_re)) {
			"curl -s -I \""$i"\" | sed -n \"s@Location: \\(.*\\)@\\1@p\"" | \
			getline x
			print x
		} else { print x }
	} }
	'
}

# This function allows to insert the message on standard input. It will
# give a count of characters used and will reverse video if chars > $max_chars
fn_interactive_update() {
	clear
	while read -n1 char ; do
		[[ "X$char" = 'X' ]] && char=' ' # XXX: ???
		case "$char" in
			''|'') echo ; echo ; tput sgr0 ; return ;; # XXX: ^M ???
			'') message=${message%?} ;;
			'') message=$(echo "$message" | sed 's/ *[^ ][^ ]* *$/ /')
					[[ "$message" = ' ' ]] && message='' ;; # XXX
			*)	message="$message$char" ;;
		esac
		tput cup 0 1
		char_count=${#message}
		tput cub $(( ${#message} + ${#char_conut} + 1 ))
		[[ $char_count -gt $max_chars ]] && tput rev || tput sgr0
		printf "$char_count $message" && tput ed
	done
	tput sgr0
}

fn_prepare_auth() {
	[[ ! -f $HOME/.netrc ]] && > $HOME/.netrc
	cp $HOME/.netrc $HOME/.netrc.$$

	site_name=${site/*:\/\/}

	# \(api.\)\?... matches api.twitter.com
	grep "machine \(api.\)\?$site_name login $my_nick" $conf_file > $HOME/.netrc

	# Check that site (without http[s]://) is in .netrc
	[[ ! $(grep $site_name $HOME/.netrc) ]] && usage no_auth
}

# For auth we will generate a new .netrc site, after moving the old one.
# When the scripts exits, restore .netrc (a sane umask was already set):
trap "mv $HOME/.netrc.$$ $HOME/.netrc 2>/dev/null" EXIT

# Options that need authentication
[[ $1 = *[fuUrmsRD] ]] && fn_prepare_auth

# For options that need xmlstarlet
if [[ $1 = *[rcd] ]] ; then
	if [[ -x $(which xml) ]] ; then
		xml=xml
	elif [[ -x $(which xmlstarlet) ]] ; then
		xml=xmlstarlet
	else
		usage no_exe "xml/xmlstarlet"
	fi
fi

# XXX: 1) Rewrite options parsing. 2) Make $site/$api etc. better.
case $1 in
	*f)	if [[ $2 != F && -f $last_file ]] ; then
			last_stat=$(sed -n "1p" $last_file)
			[[ $last_stat = *[0-9]* ]] || last_stat=1
		fi
		data_par="since_id=${last_stat}&count=$max_stats"
		#data="$site/$api/friends_timeline.xml$data_par"
		data="$site/$api/home_timeline.xml?$data_par"
		fn_download && fn_last_status 1 ;;
	*u)	curl -s -n -d "source=Qataki" --data-urlencode "status=$2" \
		  $site/$api/update.xml 1>/dev/null
		exit 0 ;;
	*U)	message= ; fn_interactive_update
		curl -s -n -d "source=Qataki" --data-urlencode "status=$message" \
		  $site/$api/update.xml 1>/dev/null
		exit 0 ;;
	*m)	if [[ $2 != F && -f $last_file ]] ; then
			last_stat=$(sed -n "2p" $last_file)
			[[ $last_stat = *[0-9]* ]] || last_stat=1
		fi
		data_par="since_id=${last_stat}&count=$max_stats"
		data="$site/$api/mentions.xml?$data_par"
		fn_download && fn_last_status 2 ;;
	*r)	[[ -z $2 ]] && { echo 'Select a number' && exit 1 ; }
		[[ $2 = *[!0-9]* ]] && { echo 'Number' && exit 1 ; }
		reply_to=$($xml sel -t -m "/statuses/status[$2]" -v id $tmp_file)
		user_name=$($xml sel -t -m "/statuses/status[$2]/user" -v screen_name $tmp_file)
		[[ -n $3 ]] && msg=$3 || { echo 'Message?' ; exit 1 ; }
		curl -s -n -d "source=Qataki" --data-urlencode "status=@$user_name $msg" \
		  -d "in_reply_to_status_id=$reply_to" $site/$api/update.xml 1>/dev/null
		exit 0 ;;
	*N) [[ "$site" == *twitter* ]] && site=http://api.twitter.com/1
		nick=$2
		data="$site/$api/user_timeline.xml?screen_name=${nick}&count=$max_stats"
		fn_download ;;
	*S)	if [[ "$site" == *twitter* ]] ; then
			site=http://search.twitter.com
		else
			site=$identica/api
		fi
		string=$2
		data="$site/search.atom?rpp=$max_stats"
		fn_download filter ;;
	*c) [[ "$site" == *twitter* ]] && usage no_impl
		# Restrive conversation URL from status id
		context_id=$($xml sel -t -m "/statuses/status[$2]" \
		  -v in_reply_to_status_id $tmp_file)
		conversation_url=$(curl -L -s $site/notice/$context_id | \
		  sed -n "/>in context</ { s/[^\"]*\"\([^#]*\).*/\1/ p
		    }")
		# Format conversation
		fn_conversation "$conversation_url" | fn_format | \
		sed '/^$/d' | less $opt_pager && exit 0 ;;
	*g) [[ "$site" == *twitter* ]] && usage no_impl
		group=$2
		api=api/statusnet
		data="$site/$api/groups/timeline.xml?id=$group&count=$max_stats"
		fn_download ;;
	*R) if grep '<feed ' $tmp_file 1>/dev/null ; then
		re1='$' re2=':' # This case is when file returned is Atom
		else
			re1='/<user>/' re2='<id>' # This is normal case (e.g., API)
		fi

		# Notice that the '$2' in last sed is the second parameter
		notice_id=$(sed -n "/<status>/,$re1 {
		  /<id>/ p
		  }" $tmp_file | sed -n "$2 s/.*$re2\([0-9]*\)<\/id>/\1/p")

		if [[ "$site" == *twitter* ]] ; then
			site=http://api.twitter.com/1
		else
			site=$identica
		fi

		curl -f -s -n -X POST -d "source=Qataki" "$site/$api/retweet/$notice_id.xml" 1>/dev/null
		exit 0 ;;
	*M)	to_user=$2 # XXX: FIX URL
		[[ $to_user = *[!a-zA-Z0-9]* ]] && { echo 'username is alphanum' ; exit 1 ; }
		[[ -n $3 ]] && dir_msg=$3 || { echo 'Enter a message' ; exit 1 ; }
		[[ "$site" == *twitter* ]] && unset api
		curl -n -X POST -d "source=Qataki" --data-urlencode "user=$to_user" --data-urlencode "text=$dir_msg" \
		  "$site/api/direct_messages/new.xml" 1>/dev/null
		echo "$site/api/direct_messages/new.xml"
		exit 0 ;;
	*d)	grep '<verified>' $tmp_file 1>/dev/null || site=$identica # verified -> tw
		fn_details $2 && exit 0 ;;
	*k)	fn_configuration ;;
	paste*) file=$2
		syntax=$(echo "$1" | awk -F: '{ print $2 }')
		[[ ! -s $file ]] && usage file_miss
		[[ -n $syntax ]] && extra_paste="-d paste_format=$syntax"
		paste=$(curl -s $extra_paste --data-urlencode "paste_code@$file" \
		  http://pastebin.com/api_public.php)
		  echo $paste && exit 1 ;;
	*h|*H)
		usage ;;
	*)	data="$site/$api/public_timeline.xml"
		[[ "$1" != *p ]] && fn_download ;;
esac

fn_extract | fn_ol_list | fn_format | less $opt_pager
